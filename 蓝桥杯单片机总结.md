# 一、观前提示

​	这篇总结最开始的定位是，帮助掌握51单片机基础的人快速入门蓝桥杯，但写到后面发现因为本人学的也不够精通，某些部分的底层无法使用文字对其进行简洁明了的叙述（主要在第五章国赛部分爆发出该问题），所以这篇文章已经偏离了最初的定位。根据本文目前的定位以及完成度，建议读者在掌握51单片机基础的情况下还需要有一定的自学能力。

​	这篇主要讲解了蓝桥杯的程序题部分，对客观题部分没有涉及，因为本人的三电学的不够扎实。

​	这篇总结推荐目标进入国赛的读者外设部分请掌握到第五章国赛部分第一节NE555频率测量，基础提高部分请掌握到第三节的前两小节即矩阵按键-按下松开切换界面和矩阵按键-长按累加/减。

​	如果你的目标是国一，那么这篇总结可能无法满足你，只能为你提供一些小小的帮助。需要了解的是，如果目标是国二以上，请掌握三电相关基础知识，当程序题难度下降时，客观题就是提供区分度的工具。顺带一提，据说国赛同分者根据最后的提交时间进行排名。

​	我希望这篇总结可以成为一个去中心化多人编写的文档，在各位有能读者的帮助下，使该文档完善为可以帮助读者登顶国一的文档，在确定了该定位后，我尽量避免在文档中留下“我”这种词汇，但因为我的语文水平不是很高，又是第一次写这种类型的文档，有些地方无法优化掉，还望各位海涵，帮我优化一下。

​	该文档所属苏州市职业大学电子信息工程学院。

# 二、基础部分

## 1、常用头文件及定义

### 1：头文件

​	在蓝桥杯中主要使用两个头文件。首先是最核心的头文件，其中包含了各种常用定义。

```c
#include <STC15F2K60S2.h>
```

​	第二个头文件主要使用其中的`_nop_()`函数，用以进行延时。

```c
#include <intrins.h>
```

### 2：宏定义

​	下面会介绍一些个人常用的宏定义，这些宏定义的主要作用是偷懒少打字，本文中的所有代码若无特殊提示，则都默认使用了本节中的宏定义。

```c
#define uchar unsigned char
#define uint unsigned int
```

​	把无符号整形与无符号字符型进行简写。

```c
#define control P2|=0XA0;P2&=0XBF;
#define wei_control P2|=0xC0;P2&=0xDF;
#define duan_control P2|=0xE0;P2&=0xFF;
#define led_control P2|=0x80;P2&=0x9F;
```

​	从上到下分别为Y5C、Y6C、Y7C、Y4C的使能，对应蜂鸣器/继电器控制、数码管位选控制、数码管段选控制、LED控制。

### 3：数码管段码

```c
uchar code duanma[]={0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90,0xBF,0xFF};
```

​	上面数组中的代码分别代表：0~9，‘-’，关闭。

​	tips-1:蓝桥杯自从提供数码管段码码值以来，数码管必考特殊字符的显示，如’E‘，’P‘，’n‘等，请务必掌握段码的计算方法。

​	tips-2:关于如何显示小数点的部分，放在了[数码管小数点显示的两种方法](#6-1)

### 4：延时及初始化函数

​	延时函数

```c
void delay(uint xms)//毫秒级延时，传入参数5则延时5ms，没有定时器准，一般用于数码管以及IIC连续调用之中。
{
    uint i,j;
    for(i=xms;i>0;i--)
        for(j=845;j>0;j--);
}
```

​	初始化函数

```c
void init(void)
{
    control;
    P0=0x00;	//关闭蜂鸣器&继电器
    wei_control;
    P0=0xFF;	//选中所有数码管
    duan_control;
    P0=0xFF;	//关闭所有数码管
    led_control;
    P0=0xFF;	//关闭所有LED
}
```

## 2、数码管显示函数

首先定义8个`uchar`用以表明第1~8个数码管。

```c
uchar one,two,three,four,five,six,seven,eight;
```

​	一般使用四个显示子函数，每个子函数包含两位数码管来进行显示。

```c
void display1(uchar one,uchar two)
{
    wei_control;
    P0=0x01;		//选中第一个数码管
    duan_control;
    P0=duanma[one];//给第一个数码管赋段码值
    delay(1);		//点亮1ms
    wei_control;
    P0=0x02;		//选中第二个数码管
    duan_control;
    P0=duanma[two];//给第二个数码管赋段码值
    delay(1);		//点亮1ms
}
```

​	其余三个子函数类同，只是更改了位选和段码。将函数放入主循环中并给`one`~`eight`赋值可实现显示功能。例：

```c
while(1)
{
    one=1;two=2;
    display1(one,two);
}
```

## 3、按键函数

### 1：独立按键

​	定义四个bit变量用于松手检测。

```c
bit S7_down=0;S6_down=0;S5_down=0;S4_down=0;
```

​	下面写S7以及S6按键的输入检测，S5及S4类同。

```c
void keyscanf(void)				//本函数中所有延时的作用均为消抖
{
    if(P30==0)
    {
        delay(5);
        if(P30==0)
        {
            S7_down=1;			//判定S7按下
        }
    }
    else if(P31==0)
    {
        delay(5);
        if(P31==0)
        {
            S6_down=1;			//判定S6按下
        }
    }
    if((S7_down==1)&&(P30==1))	//判定S7按下过，并已松开
    {
        delay(5);
        if(P30==1)
        {
            S7_down=0;			//恢复S7按下标志位
            //function
        }
    }
    else if((S6_down==1)&&(P31==1))
    {
        delay(5);
        if(P31==1)
        {
            S6_down=0;			//恢复S6按下标志位
            //function
        }
    }
}
```

​	将函数放在主循环中即可使用。

[独立按键控制数码管](#supplement1)

### 2：矩阵按键

​	矩阵按键采用行列扫描的方法，下面写S7~S4的按键输入，其余按键类同，详见（附录-矩阵按键控制数码管）。

```c
void keyscanf16(void)
{
    uchar temp;
    P3=0xFF;P4=0xEF;
    temp=P3;
    temp=temp&0x0F;
    if(temp!=0x0F)
    {
        delay(5);
        temp=P3;
        temp=temp&0x0F;
        if(temp!=0x0f)
        {
            temp=P3;
            switch(temp)
            {
               case 0xFE:/*S7-function*/break;
               case 0xFD:/*S6-function*/break;
               case 0xFB:/*S5-function*/break;
               case 0xF7:/*S4-function*/break;
            }
            while(temp!=0x0F)					//松手检测
            {
                temp=P3;
                temp=temp&0x0F;
            }
        }
    }
}
//S11~S8:P3=0xFF;P4=0XFB;case:0xFE~0XF7
//S15~S12:P3=0xDF;P4=0XFF;case:0xDE~0XD7
//S19~S16:P3=0xEF;P4=0XFF;case:0xEE~0XE7
```

[矩阵按键控制数码管](#supplement2)

## 4、LED控制

​	竞赛板LED采用共阳极连接。

```c
led_control;
P0=0xFE;	//P0=1111 1110 让P00输出低电平 点亮L1 
led_control;
P0=0x7F;	//P0=0111 1111 让P07输出低电平 点亮L8
```

[独立按键控制LED](#supplement3)

# 三、省赛常考外设

​	蓝桥杯又名蓝桥驱动背诵大赛，所以应最大化利用官方提供的底层驱动代码。官方提供的底层驱动代码为8051测试环境下的结果，竞赛板核心为IAP15F2K60S2，比51的速度快8~12倍，所以需要对其中的延时部分进行更改。

## 1、DS18B20（温度传感器）<span name = "3-1"></span>

​	首先更改官方的驱动代码。将驱动代码中所有` Delay_OneWire`函数的传入参数扩大8倍，下面以`init_ds18b20`为例。

```c
//例：DS18B20设备初始化
bit init_ds18b20(void)
{
  	bit initflag = 0;
  	
  	DQ = 1;
  	Delay_OneWire(96);
  	DQ = 0;
  	Delay_OneWire(640);
  	DQ = 1;
  	Delay_OneWire(80); 
    initflag = DQ;     
  	Delay_OneWire(40);
  
  	return initflag;
}
```

​	下面是温度获取函数，返回值为温度的整数位。

```C
uchar ds18b20_get(void)
{
    uchar temp;
    uchar low,high;
    init_ds18b20();
	Write_DS18B20(0xCC);	//忽略64位ID序列码
	Write_DS18B20(0x44);	//温度转换指令
	Delay_OneWire(200);		//等待温度转换完成
	init_ds18b20();
	Write_DS18B20(0xCC);
	Write_DS18B20(0xBE);	//读取温度数值
	low=Read_DS18B20();
	high=Read_DS18B20();
	temp=high<<4;			//舍弃高四位（正负值）
	temp|=(low>>4);			//舍弃低四位（小数部分）
	return temp;
}
```

​	[温度测量及显示](#supplement4)

​	tips1:温度传感器上电默认读数85，上电后显示85间隔一小会儿才显示正常温度属于正常现象。

​	tips2:在使用51单片机控制DS18B20时，需要在与数据引脚进行连接时需要接入一个4.7K~10K的上拉电阻，否则由于高电平不能正常输入/输出，要么通电后立即显示85℃，要么用几个月后温度在85℃与正常值上乱跳。（来自百度百科，因为没有经过验证，不知真假。）

## 2、PCF8591（A/D,D/A转换芯片）

​	首先更改官方驱动代码，将宏定义延时扩大8倍。

```c
#define DELAY_TIME 40
```

​	不使用官方驱动中提供的`IIC_SendAck()`函数，可以删去。

​	A/D转换函数，在蓝桥杯的开发板上电位器地址为0x03，光敏电阻地址为0x01。

```c
uchar IIC_AD_read(uchar add)
{
	uchar data_AD;
	IIC_Start();
	IIC_SendByte(0x90);		//cmd write
	IIC_WaitAck();
	IIC_SendByte(add);		//RB2：0x03;光敏：0x01;
	IIC_WaitAck();
	IIC_Stop();

	IIC_Start();
	IIC_SendByte(0x91);		//cmd read
	IIC_WaitAck();
	data_AD=IIC_RecByte();
	IIC_Stop();
	return data_AD;
}
```

[A/D转换及显示](#supplement5)

***

​	D/A转换函数

```c
void IIC_DA_out(uchar dat)
{
	IIC_Start();
	IIC_SendByte(0x90);		//cmd write
	IIC_WaitAck();
	IIC_SendByte(0x40);		//cmd ANALOGUE OUTPUT ENABLE
	IIC_WaitAck();
	IIC_SendByte(dat);
	IIC_WaitAck();
	IIC_Stop();
}
```

​	传入值`dat`范围为0~255，自行转换，例：`IIC_AD_write(102);`输出电压约为2V。

​	[D/A输出](#supplement6)

## 3、EEPROM（外部存储芯片）

​	首先更改官方驱动代码，将宏定义延时扩大8倍。

```c
#define DELAY_TIME 40
```

​	不使用官方驱动中提供的`IIC_SendAck()`函数，可以删去。

​	向EEPROM写入一个字节数据函数。

```c
void IIC_EEPROM_WRITE(uchar add,uchar dat)
{
	IIC_Start();
	IIC_SendByte(0xA0);		//cmd write
	IIC_WaitAck();
	IIC_SendByte(add);		//要写入的地址
	IIC_WaitAck();
	IIC_SendByte(dat);		//要写入的数据
	IIC_WaitAck();
	IIC_Stop();
}
```

***

​	从EERPOM中读取一个字节数据函数。

```c
uchar IIC_EEPROM_READ(uchar add)
{
	uchar dat;
	IIC_Start();
	IIC_SendByte(0xA0);		//cmd write
	IIC_WaitAck();
	IIC_SendByte(add);		//要读取的地址
	IIC_WaitAck();
	IIC_Stop();
	
	IIC_Start();
	IIC_SendByte(0xA1);		//cmd read
	IIC_WaitAck();
	dat=IIC_RecByte();		//读出数据
	IIC_Stop();
	return dat;
}
```

​	[EEPROM读写](#supplement7)

## 4、DS1302（时钟芯片）

​	为了与IIC进行区别，首先对官方驱动代码中`sbit`的各个引脚定义进行更改，如下。

```c
sbit SCLK = P1^7;		
sbit IO = P2^3;		
sbit CE = P1^3;   // DS1302复位
```

​	然后删除驱动代码中所有的`_nop_();`函数。

***

​	第一处更改属于个人习惯，不更改也没有影响。

```c
void Write_Ds1302(unsigned  char temp) 
{
	unsigned char i;
	for (i=0;i<8;i++)     	
	{ 
		SCLK=0;
		IO=temp&0x01; 
		SCLK=1;
        temp>>=1;		//与官方原代码相比，把位移放在了SCLK=1之后。
	}
}  
```

***

​	第二处更改是为了方便时间变量的显示。具体原因以及原理请自行结合DS1302的datasheet进行研究。

```c
unsigned char Read_Ds1302_Byte ( unsigned char address )
{
 	unsigned char i,temp=0x00;
    uchar dat1,dat2;			//调整返回值用
 	CE=0;
 	SCLK=0;
 	CE=1;
 	Write_Ds1302(address);
 	for (i=0;i<8;i++) 	
 	{		
		SCK=0;
		temp>>=1;	
 		if(IO)
 		temp|=0x80;	
 		SCK=1;
	} 
	IO=0;
    dat1=temp/16;		
    dat2=temp%16;
    temp=dat1*10+dat2;		//对返回值进行调整
	return (temp);			
}
```

***

​	时钟芯片初始化函数。

```c
void DS1302_init(void)
{
    uchar add=0x80,i;
    Write_Ds1302_Byte(0x8E,0x00);		//关闭写保护
    for(i=0;i<7;i++)
    {
        Write_Ds1302_Byte(add,time[i]);	//数组time的释义见下面时钟芯片使用示例
        add=add+2;
    }
    Write_Ds1302_Byte(0x8E,0x80);		//打开写保护
}
```

***

​	时钟芯片读取函数。

```c
void DS1302_timeget(void)
{
    uchar add=0x81,i;
    Write_Ds1302_Byte(0x8E,0x00);		//关闭写保护
    for(i=0;i<7;i++)
    {
        time[i]=Read_Ds1302_Byte(add); //读取各个时间参数值
        add=add+2;
    }
    Write_Ds1302_Byte(0x8E,0x80);		//打开写保护
}
```

***

[时钟芯片应用](#supplement8)

# 四、基础提高

## 1、数码管显示（优化消隐的两种方法）

​	在[温度测量及显示](#supplement4)以及[A/D转换及显示](#supplement5)两个工程中，可以明显观察到最后一位数码管要比其余的数码管更亮。其原因是，其余数码管是严格按照`delay(1)`的时间进行点亮，但是最后一个数码管的点亮时间是包含`display1(one,two)`上方所有主循环体内的代码运行时间。这就会导致最后一位数码管点亮的时间长于其它数码管，在人眼看起来就是最后一位数码管明显更亮。知道了原因，我们就可以对其进行优化了，下面有两种优化方法。

### 1：简单直接粗暴法<span name = "4-1-1"></span>

​	既然最后一位数码管亮了太久，那我们直接在它点亮`delay(1)`后将其关闭，就可以避免。

```c
//此处关闭0x02是因为只用到了两位数码管，使用全部数码管时，请关闭display4();中的0x80。
void display1(uchar one,uchar two)
{
    wei_control;
    P0=0x01;		//选中第一个数码管
    duan_control;
    P0=duanma[one];//给第一个数码管赋段码值
    delay(1);		//点亮1ms
    wei_control;
    P0=0x02;		//选中第二个数码管
    duan_control;
    P0=duanma[two];//给第二个数码管赋段码值
    delay(1);		//点亮1ms
		
	wei_control;
	P0=0x02;		//选中最后一个点亮的数码管
	duan_control;
	P0=0xFF;		//关闭数码管
}
```

​	将[温度测量及显示](#supplement4)中的显示函数替换为上方的函数可以观察到异常现象消失。

### 2：轻微复杂优美法

​	上面分析原因时我们知道了，每位数码管点亮时间不统一是主要原因，那么有没有一种方法可以让我们精确的控制每一位数码管点亮的时间呢？这时就考虑到了使用定时器对点亮数码管时间进行控制的可能性。IAP15F2K61S2有三个定时器（0/1/2）为了其余操作使用定时器时比较方便，这里使用定时器2进行控制。BTW，本文以下的所有例程都将采用此方法控制数码管显示。

```c
uchar display[8]={1,2,3,4,5,6,7,8};//此数组下标0~7分别对应第1~8位数码管。
uchar discount=0;					//用于计数点亮到第几个数码管

void Timer2Init(void)		//1毫秒@12.000MHz
{
	AUXR |= 0x04;		//定时器时钟1T模式
	T2L = 0x20;		//设置定时初值
	T2H = 0xD1;		//设置定时初值
	AUXR |= 0x10;		//定时器2开始计时
    IE2 |= 0x04;	//开启定时器2中断
    EA = 1;			//打开总中断
}

void tim2_isr() interrupt 12 //定时器2的中断服务号为12
{
    wei_control;
    P0=(1<<discount);			//0000 0001→0000 0010以此类推
    duan_control;
    P0=duanma[display[discount]];	//段码
    if(++discount==8)discount=0;
}
```

​	[使用定时器消隐的A/D转换及显示](#supplement9)

## 2、LED控制优化

​	因为竞赛板的P0口通过573的控制可以选择多种外设进行控制，所以如果直接给P0赋LED值有很大概率会影响到数码管的显示，还有一些题目中某些LED在一定条件下同时点亮，一定条件下点亮某几个，如果都采用直接赋值很容易导致逻辑上的混乱。所以我们定义一个`uchar`变量用以表示LED的状态。本文以下的所有例程都将采用此方法控制LED。

```c
uchar led=0xFF;	//初始化 默认关闭所有LED
while(1)
{
    led&=0xFE;	 //1111 1111 & 1111 1110 需要点亮L1，将变量的值调整好，同时使用位运算只改变L1位置的值
    led_control;//选择573，使P0控制LED
    P0=led;		//将修改好的LED值送给P0口
    
    led|=0x01;	//1111 1110 | 0000 0001 需要关闭L1，将变量的值调整好，同时使用位运算只改变L1位置的值
    led_control;//选择573，使P0控制LED
    P0=led;		//将修改好的LED值送给P0口
}
```

## 3、按键扩展

​	近年组委会发现外设不好整活，开始回头深挖基础部分的难度，例如第九届省赛的LED亮暗控制、第八届省赛按下显示某一界面，松开后还原、第十届国赛矩阵空出串口的两条线、第十一届国赛要求按键不能干扰外设模块的测量。本节中所有函数只给出最简化模板以及例程。在考场上可能会出现例如矩阵按键双击等要求（不负责任猜测只有极小概率出现在国赛中），所以请务必**理解**本节中的函数功能。

### 1：独立按键-按下松开切换界面

​	通过一个标志位来判断按键的情况，来切换界面，非常简单。

[按下松开切换界面示例](#supplement10)

### 2：独立按键-长按累加/减<span name = "3-3-2"></span>

​	在按下判定时添加一个松手检测，缺点：由于使用了`while`循环进行松手检测，在按键按下到松手检测完成时，程序近乎等于暂停运行。

```c
void keyscanf(void)				//本函数中所有延时的作用均为消抖
{
    if(P30==0)
    {
        delay(5);
        if(P30==0)
        {
            S7_down=1;			//判定S7按下
			while(!P30)
			{
				delay(100);				
				if(++S7_time>=8)	//按下时间超过800ms判定为长按成功
				{
					S7_time=0;
					number++;			//此处以加法举例，减法类同
					if(number==100)
					number=0;
					break;			//跳出循环以显示
				}
			}
        }
    }
    if((S7_down==1)&&(P30==1))	//判定S7按下过，并已松开
    {
        delay(5);
        if(P30==1)
        {
            S7_down=0;S7_time=0;			//恢复S7按下标志位与松手检测标志位
        }
    }
}
```

[长按累加示例](#supplement11)

### 3：独立按键-双击

​	因为从来没有考过双击按键，所以本节的代码非常简陋。目前已知缺点如下：

​	缺点1：没有确定双击之间的时间间隔。可行的优化方向：定时器中对`key_double`变量定时清零。

​	缺点2：执行双击动作前必定执行单击动作。可行的优化方向：同一个按键的单击/双击功能，绝大概率不会要求在同一个界面下实现，可依靠界面标志位区分。

```c
void keyscanf(void)				//本函数中所有延时的作用均为消抖
{
    if(P30==0)
    {
        delay(5);
        if(P30==0)
        {
            S7_down=1;			//判定S7按下
        }
    }
    if((S7_down==1)&&(P30==1))	//判定S7按下过，并已松开
    {
        delay(5);
        if(P30==1)
        {
            S7_down=0;		//恢复S7按下标志位
			if(key_double!=2)
			{
				key_double++;
			}
			if(key_double==2)
			{
				key_double=0;
				number++;
				if(number==100)
					number=0;
			}
        }
    }
}
```

[双击示例](#supplement12)

### 4：矩阵按键-避开串口

​	串口线为P30/P31两根线，在矩阵行列扫描中不干扰这两条线就可以了。这里给出一种类独立按键的写法以便理解。

[矩阵按键控制数码管-避开串口](#supplement13)

### 5：矩阵按键-不干扰主循环

​	观前提示：这个写法是我在第十一届国赛考场上突然想到的，所以看起来就是把独立按键写法和定时器随便揉了一下。写在这里主要是想分享一下，追求更高级的方法请自行利用搜索引擎查询关键词“矩阵按键”、“状态机”、“定时器消抖”。

​	在[独立按键-长按累加/减](#3-3-2)中我们分析过，在松手检测时使用`while(1)`循环会导致主循环近乎停止，虽然使用类独立按键的写法可以规避，但个人觉得在不用避开串口又需要利用很多按键的情况下写起来很麻烦，所以我又想到了我们的好朋友“定时器”，所以想出了下面的写法。下方给出的代码，比我在考场上现想的优化了很多，但我个人还是感觉很蠢，没考场上的那么蠢罢了。

​	[矩阵按键-不干扰主循环](#supplement14)

# 五、国赛常考外设

## 1、NE555频率测量

​	根据近两年的情况组委会有把该考点下放到省赛以提高难度的想法，目标省一的读者请务必掌握该模块。在频率测量时要求将开发板右侧的P34引脚和SIGNAL（NE555信号输出）引脚进行短接。

​	由于NE555自身的特性，在调整电位器Rb3时出现前大半部分旋转时频率稳步增加，旋转到最后时频率猛然增加的现象的话，是正常的。

### 1：使用定时器脉冲捕获功能测量（仅频率）

​	该方法的原理是将定时器配置为计数器模式，对外部脉冲进行捕获计数。通过查看手册可以得知，定时器0作为计数器使用时，对P34引脚进行脉冲捕获计数。所以该方法固定配置定时器0为计数器。

```c
void Timer0Init(void) //计数模式
{
	AUXR |= 0x80;
	TMOD |= 0x05; //  C/~T置1 令定时器0作计数器使用  工作模式为16位不可重装载
	TL0=0;
	TH0=0;
	TR0=1;
}
```

​	在这之后只要每秒计算定时器0的计数值，就可以得到脉冲的频率。

​	[NE555-脉冲捕获](#supplement15)

### 2：使用定时器测量（频率&占空比）

​	频率与周期的关系为T=1/f。其中T=周期，单位：S，f=频率，单位：Hz。第七届国赛要求最高可测得20kHz频率，根据Nyquist采样定理，采样时间应设置为25us(1/40000=0.000025S)。为减小误差，此处使用5us进行采样。第七届国赛要求最低可测的200Hz频率（1/200=0.005S），NE555最低可产生100Hz左右的频率，即一个周期在10ms左右，所以此处每秒采集一次，每次30ms。

```c
void Timer0Init(void)		//5微秒@12.000MHz
{
	AUXR |= 0x80;		//定时器时钟1T模式
	TMOD &= 0xF0;		//设置定时器模式
	TL0 = 0xC4;		//设置定时初值
	TH0 = 0xFF;		//设置定时初值
	TF0 = 0;		//清除TF0标志
}

void tm0_isr() interrupt 1
{
  if(P34==0)				//当前处于反周期？
	{
		fan++;					//反周期计数
		if(t_flag==0)		//正周期计数完毕
		{
			t_flag=1;
			zheng_now=zheng;		//提取正周期计数值，用于计算
			zheng=0;
		}
	}
	else if(P34==1)		//当前处于正周期？
	{
		zheng++;				//正周期计数
		if(t_flag==1)		//反周期计数完毕
		{
			t_flag=0;
			fan_now=fan;				//提取反周期计数值，用于计算
			fan=0;
		}
	}
}

void Timer2Init(void)		//1毫秒@12.000MHz
{
	AUXR |= 0x04;		//定时器时钟1T模式
	T2L = 0x20;		//设置定时初值
	T2H = 0xD1;		//设置定时初值
	AUXR |= 0x10;		//定时器2开始计时
    IE2 |= 0x04;	//开启定时器2中断
    EA = 1;			//打开总中断
}

void tim2_isr() interrupt 12 //定时器2的中断服务号为12
{
    wei_control;
    P0=(1<<discount);			//0000 0001→0000 0010以此类推
    duan_control;
    P0=duanma[display[discount]];	//段码
    if(++discount==8)discount=0;//计数值清零，以重新从第一位数码管开始
	
		//以下为NE555频率测量部分
		check_time++;						//扫描计时
		if(check_time==969)
		{
			TR0 = 1;ET0 = 1 ;					//开始频率采集
		}
		else if(check_time==999)
		{
			check_time=0;
			TR0 = 0;ET0 = 0 ;
			Time=(fan_now+zheng_now)*5; //计算一个周期的时间，因为5us一次中断，所以乘以5，此处得到的时间单位是us。
			freq=1000000/Time;         //因为时间单位是us，所以要乘以10^-6，这里直接移到分子上。此处得到的频率单位是Hz。
		}
}
```

​	此方法因为分别计算了反周期与正周期的时间，所以可以计算出占空比。[NE555-定时器测量](#supplement16)

## 2、超声波测距

​	使用超声波时需要将开发板J2排针上的1-3,2-4引脚进行短接。开发板上超声波模块的测量最小距离为2cm，被测平面应大于0.5M<sup>2</sup>。所以在测试时尽量用A4纸大小左右的书本作为被测平面，得到的结果会比较准确。

​	根据原理图可知，超声波可以接受的信号频率在40kHz左右，所以我们需要使发射引脚发送40kHz左右的脉冲信号，即一个周期25us。在本文的例程中，使用软件延时来控制周期时间，但软件延时的时间受单片机的晶振频率影响，本文使用的软件延时在11.0592MHz下可以将一个周期的时间控制为大约25us。但从第十届起蓝桥杯采用机器阅卷，要求将单片机的晶振频率设置为12MHz，如果在12MHz下使用下面的发送波形函数，将会产生误差。因为没有测试过这个误差对结果的具体影响，如果对精度有更高要求，请自行更改延时时间或使用定时器。

```c
#define sound_somenop {_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();}
//延时宏定义
sbit TX=P1^0; //超声波模块的发射引脚与单片机的P1.0引脚连接
void send_wave(void)  //向超声波模块的发射引脚发送8个40kHz脉冲方波
{
	uchar i=8;
	do
	{
		TX=1;  //高电平
        //为节省定时器资源这里使用了软件延时，这里的延时约为12.5us,测试环境为11.0592MHz,在移植时请注意单片机的工作频率！
		sound_somenop;sound_somenop;sound_somenop;sound_somenop;sound_somenop;
		sound_somenop;sound_somenop;sound_somenop;sound_somenop;sound_somenop;
		TX=0;  //低电平
		sound_somenop;sound_somenop;sound_somenop;sound_somenop;sound_somenop;
		sound_somenop;sound_somenop;sound_somenop;sound_somenop;sound_somenop;
	}
	while(i--);
}
```

​	在发送完成后，就只需要等待接收引脚接收到回波，然后出计算时间的差值，根据声音的传播速度大约为340m/s，就可以计算出超声波再距离多远处遇到障碍物被反射回来。

​	根据上述结论，我们需要解决的问题就是如何计算这一段时间的值，这里我使用定时器1进行计时，下面是相应代码，具体含义见注释。

```c
void Timer1Init(void)	//定时器1初始化	
{
	AUXR |= 0x40;		//定时器时钟1T模式
	TMOD &= 0x0F;		//设置定时器模式
}

void distance_get(void)
{
	if(sound_flag==1)				//以一定时间间隔进行超声波距离检测，原因见下等待回波部分注释
	{
		sound_flag=0;					//标志位清零
		send_wave();					//发送波形函数
		TR1=1;								//启动定时器1，开始计时
		while((RX==1)&&(TF1==0))			//发送波形完成后使用一段死循环等待回波，收到回波后RX引脚会被拉低，从而跳出循环
		{															//如果定时器1计数值溢出，则也跳出循环，防止在检测超范围时程序跑飞。
																	//如果不限制更新数据的时间，程序运行的大部分时间会在跑这段循环。
				//下面这段代码是为了照顾使用软件延时进行数码管显示
				//程序在跑入死循环等待回波时，main函数while(1)中的显示函数将不会被运行
				//此时可以观察到的现象大概为数码管闪烁
				//解决方法如下，当定时器1计时到一定时间时，运行一次显示函数
//			if((TH1==0x40)|(TH1==0x80)|(TH1==0xA0)|(TH1==0xE0))
//			{
//				display1(one,two);display2(three,four);display3(five,six);display4(seven,eight);
//			}
		}
		TR1=0;							//收到回波或定时器1计数值溢出，令定时器1停止计时。
		if(TF1==1)					//对定时器1的溢出标志位进行判断
		{
			TF1=0;						//将定时器1的溢出标志位重新置0
			distance=9999;		//9999 代表无返回，溢出
		}
		else
		{
			sound_time=TH1;		
			sound_time<<=8;
			sound_time|=TL1;	//将定时器1中的计数值取出
			
			distance=(uint)(sound_time*0.017);
			//此处的公式为，d=t/1000000*340/2*100
			//定时器的计数值增加方式为，每经过一个机器周期，计数器中值加1，直到计数器中的值溢出。
			//以STC89C52单片机工作在12MHz下为例，52单片机中，一个机器周期=12个晶振周期，12M/12=1M，除以1M得到具体时间，单位为S。
			//声音的传播速度约为340m/s
			//因为测得的时间是超声波往返一起花费的时间，所以要除以2。
			//这样计算出来后单位为m，因为题目中一般要求为cm，所以乘以100。
			
			distance=distance/12;
			//上方注释的计算是以52单片机为例的，但是在IAP15F2K61S2单片机中，一个机器周期=一个晶振周期。
			//所以当两者都处于12MHz下时，15单片机比52单片机快12倍，这里将多的12倍除去。
		}
		TH1=0;	//将定时器1的计数值清零
		TL1=0;
	}
}
```

​	这里给出的例程中，数码管显示是采用的定时器方法。[超声波测距](#supplement17)

## 3、温度的小数显示

​	在第三章的[DS18B20](#3-1)部分中，我们获取了温度的全部数据，但舍弃了一些信息，即高四位的正负值和低四位的小数部分，在这一节中我们需要拿到低四位的小数部分。

​	因为需要拿到更多的数据，所以需要对变量类型做出改变，从`unsigned char`调整为`long`，详细见下方注释。

```c
//温度数据处理
long DS18B20_GET(void)
{
	uchar low,high;
	long temp;
	init_ds18b20();
	Write_DS18B20(0xCC);		//忽略64位ID序列码
	Write_DS18B20(0x44);		//温度转换指令
	Delay_OneWire(200);			//等待温度转换完成
	init_ds18b20();
	Write_DS18B20(0xCC);
	Write_DS18B20(0xBE);		//读取温度数值
	low=Read_DS18B20();
	high=Read_DS18B20();
    //处理获得到的数据
	temp=(high&0x0F);//舍弃高四位（正负值）
	temp<<=8;		//左移八位，给低八位数据留出空间
	temp|=low;		//将高四位数据与低八位数据进行拼接
    //根据DS18B20的数据手册可知，在分辨率为12位的情况下，温度值的分辨率为0.0625℃
    //根据上述数据可知如果想要得到实际的温度值，需要将得到的数据乘以0.0625
    //但是这样就会产生浮点型运算，会带来两个问题
    //1:浮点运算会更吃资源（我也不知道会比整数多吃多少资源）
    //2:浮点型数据不方便我们处理在数码管上的显示
    //这里的解决方法是乘以0.0625后再乘以10000，将其扩大为整数，这也是为什么一开始将变量定义为long型
	temp=temp*625;
    //例：温度原本值为：12.3456，根据上方计算后得到的值为：123456
	return temp;
}

//温度数据显示
//例：wendu=123456
display[0]=wendu/100000;			// 123456/100000=1;
display[1]=wendu%100000/10000+10;	// 123456%100000/10000=2; +10是因为这里要显示小数点
display[2]=wendu%10000/1000;		// 123456%10000/1000=3;
display[3]=wendu%1000/100;			// 123456%1000/100=4;
//题目中一般要求保留两位小数，即最后的5、6不需要显示
```

​	[温度的小数显示](#supplement18)

​	tips:前四位数码管会拖影，原因未知。

## 4、串口

​	该功能只在第五届国赛以及第十届国赛中有考察，顺便一提，第十一届国赛不知道是不是因为疫情原因，相比第十届国赛，难度大幅下降。

​	对于串口功能，需要理解的是，串口是一种设备之间的通信方式，类似与IIC，通信的双方需要确定一些参数来确保信息传递的正确。在IIC中这个参数是时序，包括起始时序、停止时序等；在串口中这些参数为串口号、波特率、数据位、校验位、停止位、流控位。

​	蓝桥杯开发板使用的芯片包含两个串口（UART1/UART2）比赛中没有特别说明则应该使用UART1因为其引脚与CH340芯片以及USB接口相连，可以不外接CH340芯片模块。

​	在使用串口功能时需要打开串口中断，`ES=1;`,对应的中断服务号为`interrupt 4`。下面以串口号：1、波特率：4800、数据位：8、校验位：none、停止位：1为例，进行串口初始化。

```c
void main()
{
    UartInit();
    ES=1;
}
//使用STC-IP烧录软件中的波特率生成功能
//UART选择串口1，UART数据位选择8位数据，波特率发生器自行选择，定时器时钟选择1T
//系统频率以及波特率请按题目要求进行选择
void UartInit(void)		//4800bps@12.000MHz
{
	SCON = 0x50;		//8位数据,可变波特率
	AUXR |= 0x40;		//定时器1时钟为Fosc,即1T
	AUXR &= 0xFE;		//串口1选择定时器1为波特率发生器
	TMOD &= 0x0F;		//设定定时器1为16位自动重装方式
	TL1 = 0x8F;		//设定定时初值
	TH1 = 0xFD;		//设定定时初值
	ET1 = 0;		//禁止定时器1中断
	TR1 = 1;		//启动定时器1
}
```

​	在串口接收到数据后，会将标志位`RI`置为1，同时数据会存入`SBUF`之中，我们只需要在`RI`为1时，将`SBUF`中存储的数据拿出，就收到了发送方发送的数据。需要提醒的时`RI`需要软件复位，即拿出数据后，需要我们将`RI`置0。

```c
//usart1_rx_buffer为接收区，变量类型为uchar
//usart1_rx_count为接收计数，作为接收区的索引，同时计算已经接收了几个数据
void uart_isr() interrupt 4
{
	if(RI)			//收到数据，RI被硬件置1
	{
		usart1_rx_buffer[usart1_rx_count]=SBUF;		//取出接收到的数据
		usart1_rx_count++;							//索引+1
		RI=0;										//取出数据后将RI软件置0
	}
}
```

​	完成上面的代码后，另一设备通过串口向单片机发送的数据就被存储在了`usart1_rx_buffer`数组中，只需要根据`usart1_rx_count`判断是否接收到了足够的数据。以第五届决赛为例，查询指令为`AAASSS`，即当`usart1_rx_count>=5`时就可以认为接收到了足够的数据，然后对`usart1_rx_buffer`中的内容进行判断，看是否为`AAASSS`。

```c
//数据如果较长，可以建立一个数组用于对比
uchar text[6]={"AAASSS"};

if(接收完成)
{
   for(i=0;i<6;i++)							//已知要判断的数据长度为6
    {
        if(usart1_rx_buffer[i]!=text[i])	//不吻合
            check_flag=0;					//检查标志位置0
        else
            check_flag=1;					//完全吻合，检查标志位置1
    } 
}
```

```c
//数据如果比较短，可以直接判断每一位元素的值然后进行位运算
if((usart1_rx_buffer[0]='S')&(usart1_rx_buffer[1]='T')&(usart1_rx_buffer[2]='\r')&(usart1_rx_buffer[3]='\n'))
			{
				wendu_temp1=wendu/100000*10+wendu%100000/10000;
				wendu_temp2=wendu%10000/1000*10+wendu%1000/100;
				sprintf((char*)usart1_tx_buffer,"$%0.2bd,%0.2bd,%0.2bd\r\n",juli,wendu_temp1,wendu_temp2);
				send(usart1_tx_buffer,11);
			}
```

​	在接收到数据后，通常会要求我们返回一些信息，这时候就需要编写发送功能的代码。

```c
void send(uchar *p,uchar length)//指针指向包含需要发送的数据的数组，length为长度索引
{
	uchar i;
	for(i=0;i<length;i++)
	{
		SBUF=*(p+i);			//将数据放入SBUF中进行发送
		while(TI==0);			//发送完成后TI被硬件置1，跳出while（1）循环
		TI=0;					//将TI软件置0
	}
}
```

​	具体应用见第五届国赛以及第十届国赛代码

# 六、疑难杂症以及细节补足

## 1、数码管小数点显示的两种方法<span name = "6-1"></span>

​	这一节本应出现在第二章基础部分中，但因为在里面要求了读者自行掌握段码计算方法，所以决定把这部分内容放在这里。同时需要说明的是，这里不会讲解段码的计算方法，因为这东西网上满天飞，珍惜生命的人应该学会拒绝重复造轮子。

​	根据段码计算方法，以及蓝桥杯提供的开发板原理图，可以得知，只要让段码`&0x7F`就可以点亮相应段码数字的小数点位。根据上述结论，我们就得到了两种解决方法。

​	解决方法一：一劳永逸法。顾名思义，该方法只需要一次大量劳动，就是算出之前段码中各个元素`&0x7F`后的值，然后将计算后的结果依次放进去，这样在需要显示小数点时只需要`+10`就可以将索引对齐。因为该方法比较灵活所以非常推荐。

```c
uchar code duanma[]={0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90,
									 0x40,0x79,0x24,0x30,0x19,0x12,0x02,0x78,0x00,0x10,
									 0xBF,0xFF};
//定时器扫描-数码管显示
display[0]=2+10;//例：显示‘2.’
display[1]=20; //例：显示'-'
display[2]=21; //例：关闭

//软件延时-数码管显示
one=2+10;//例：显示‘2.’
two=20; //例：显示'-'
three=21; //例：关闭
```

​	解决方法二：偷懒万岁法。前提一：需要显示小数点的数码管位数不变。例：题目要求电压测量数码管显示中永远是x.x，这时可以认为第一位在电压测量时永远是需要显示小数点的状态。前提二：本方法只建议在”[软件延时-数码管显示](#4-1-1)“中使用，这是为了避免在定时器中加入过多语句。

```c
//此处关闭0x02是因为只用到了两位数码管，使用全部数码管时，请关闭display4();中的0x80。
void display1(uchar one,uchar two)
{
    wei_control;
    P0=0x01;		//选中第一个数码管
    duan_control;
    if(dianya_flag==1)	//判断当前是否处于电压测量
    {					//注：此处判断电压测量状态是因为上面举例中使用了该条件，具体情况请具体分析
        P0=duanma[one]&0x7F;//显示小数点
    }
    else
    P0=duanma[one];//给第一个数码管赋段码值
    delay(1);		//点亮1ms
    wei_control;
    P0=0x02;		//选中第二个数码管
    duan_control;
    P0=duanma[two];//给第二个数码管赋段码值
    delay(1);		//点亮1ms
		
	wei_control;
	P0=0x02;		//选中最后一个点亮的数码管
	duan_control;
	P0=0xFF;		//关闭数码管
}
```

## 2、DS18B20读取遇到的问题

​	1、当程序中包含读取DS18B20的代码与定时器中断代码时，可能会遇到DS18B20读取数据异常的情况，现象为数码管显示数字在正常与异常之间闪烁变换。初步分析bug原因为在DS18B20读取的同时产生了定时器中断，同时定时器中断中的代码运行时间过长，从而扰乱了DS18B20的时序。

​	解决方法：因为并没有实际解决过这个问题，在这里给出两个方法仅供参考。方法一：首先关闭定时器中断，观察异常现象是否消失，如果消失，则可以锁定问题大概率与上述推断一致。这时我们需要优化定时器中的语句数量，减少定时器中断中的运行时间。方法二：首先说明我个人不推荐这个方法，该方法就是把DS18B20读取函数也放入定时器中，但极其不推荐这样做，如果这样做了之后，异常现象消失且程序运行正常、稳定，那就用这个方法吧，能解决bug的方法就是好方法。

## 3、更优化的判断接收完成（串口）

​	创建一个`usart1_rx_flag;`与`usart1_rx_done`变量，变量类型：`unsigned char`。当接收到数据，即进入串口中断时，将其置1。同时在定时器中，每1ms监测该变量，当其大于等于1时，则`usart1_rx_flag++`，当`usart1_rx_flag`大于等于30时，即30ms没有接收到数据，认为一次数据接收完成，将`usart1_rx_flag`置0，`usart1_rx_done`置1。

​	原理为，串口发送数据的过程很快，当第一个数据来到时，进入串口中断`usart1_rx_flag`置1，然后在定时器中开始以1ms为周期进行自加。此时，若有第二个数据进来，则又会进入串口中断将`usart1_rx_flag`置1，则可以认为，如果一个数据串没有发送完成，`usart1_rx_flag`不会到达30，因为会一直进入串口中断将`usart1_rx_flag`置1。直到30ms没有接收到数据，即30ms没有进入串口中断，认为一次数据串接收完成`usart1_rx_flag`置0，`usart1_rx_done`置1。

​	具体应用见第十届国赛代码，需要注意的是，如果发送方可以做到30ms内发送两个指令即两个数据串，则需要调整这个值。

# 七、附录

## 1、独立按键控制数码管<span name = "supplement1"></span>

```c
//function:S7:+1;S6:-1;S5:+2;S4:-2; temp=0~99
#include <STC15F2K60S2.h>
#include <intrins.h>

#define uchar unsigned char
#define uint unsigned int
	
#define control P2|=0XA0;P2&=0XBF;
#define wei_control P2|=0xC0;P2&=0xDF;
#define duan_control P2|=0xE0;P2&=0xFF;
#define led_control P2|=0x80;P2&=0x9F;

uchar code duanma[]={0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90,0xBF,0xFF};

uchar one,two,three,four,five,six,seven,eight;

bit S7_down=0;S6_down=0;S5_down=0;S4_down=0;

void display1(uchar one,uchar two);
void delay(uint xms);
void init(void);
void keyscanf(void);

uchar number=5;

void main(void)
{
	init();
	while(1)
	{
		
		one=number/10;two=number%10;

		keyscanf();
		display1(one,two);
	}
}

void keyscanf(void)				//本函数中所有延时的作用均为消抖
{
    if(P30==0)
    {
        delay(5);
        if(P30==0)
        {
            S7_down=1;			//判定S7按下
        }
    }
    else if(P31==0)
    {
        delay(5);
        if(P31==0)
        {
            S6_down=1;			//判定S6按下
        }
    }
		else if(P32==0)
    {
        delay(5);
        if(P32==0)
        {
            S5_down=1;			
        }
    }
		else if(P33==0)
    {
        delay(5);
        if(P33==0)
        {
            S4_down=1;			
        }
    }
    if((S7_down==1)&&(P30==1))	//判定S7按下过，并已松开
    {
        delay(5);
        if(P30==1)
        {
            S7_down=0;			//恢复S7按下标志位
            number=number+1;
						if(number==100)
							number=0;
        }
    }
    else if((S6_down==1)&&(P31==1))
    {
        delay(5);
        if(P31==1)
        {
            S6_down=0;			//恢复S6按下标志位
            number=number-1;
						if(number==255)		//uchar变量为0后再减1会变为255
							number=99;
        }
    }
		else if((S5_down==1)&&(P32==1))
    {
        delay(5);
        if(P32==1)
        {
            S5_down=0;			
            number=number+2;
						if(number>=100)
							number=0;
        }
    }
		else if((S4_down==1)&&(P33==1))
    {
        delay(5);
        if(P33==1)
        {
            S4_down=0;			
            number=number-2;
						if(number>=254)		
							number=99;
        }
    }
}

void display1(uchar one,uchar two)
{
    wei_control;
    P0=0x01;		//选中第一个数码管
    duan_control;
    P0=duanma[one];//给第一个数码管赋段码值
    delay(1);		//点亮1ms
    wei_control;
    P0=0x02;		//选中第二个数码管
    duan_control;
    P0=duanma[two];//给第二个数码管赋段码值
    delay(1);		//点亮1ms
}

void delay(uint xms)//毫秒级延时，传入参数5则延时5ms，没有定时器准，一般用于数码管以及IIC连续调用之中。
{
    uint i,j;
    for(i=xms;i>0;i--)
        for(j=845;j>0;j--);
}

void init(void)
{
    control;
    P0=0x00;	//关闭蜂鸣器&继电器
    wei_control;
    P0=0xFF;	//选中所有数码管
    duan_control;
    P0=0xFF;	//关闭所有数码管
    led_control;
    P0=0xFF;	//关闭所有LED
}
```

## 2、矩阵按键控制数码管<span name = "supplement2"></span>

```c
//function: 给数码管赋对应按键的值。
#include <STC15F2K60S2.h>
#include <intrins.h>

#define uchar unsigned char
#define uint unsigned int
	
#define control P2|=0XA0;P2&=0XBF;
#define wei_control P2|=0xC0;P2&=0xDF;
#define duan_control P2|=0xE0;P2&=0xFF;
#define led_control P2|=0x80;P2&=0x9F;

uchar code duanma[]={0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90,0xBF,0xFF};

uchar one,two,three,four,five,six,seven,eight;

void display1(uchar one,uchar two);
void delay(uint xms);
void init(void);
void keyscanf16(void);

uchar number=5;

void main(void)
{
	init();
	while(1)
	{
		
		one=number/10;two=number%10;

		keyscanf16();
		display1(one,two);
	}
}

void keyscanf16(void)
{
    uchar temp;
    P3=0xFF;P4=0XEF;
    temp=P3;
    temp=temp&0x0F;
    if(temp!=0x0F)
    {
        delay(5);
        temp=P3;
        temp=temp&0x0F;
        if(temp!=0x0f)
        {
            temp=P3;
            switch(temp)
            {
               case 0xFE:number=7;/*S7-function*/break;
               case 0xFD:number=6;/*S6-function*/break;
               case 0xFB:number=5;/*S5-function*/break;
               case 0xF7:number=4;/*S4-function*/break;
            }
            while(temp!=0x0F)					//松手检测
            {
                temp=P3;
                temp=temp&0x0F;
            }
        }
    }
		
	P3=0xFF;P4=0XFB;
	temp=P3;
    temp=temp&0x0F;
    if(temp!=0x0F)
    {
        delay(5);
        temp=P3;
        temp=temp&0x0F;
        if(temp!=0x0f)
        {
            temp=P3;
            switch(temp)
            {
               case 0xFE:number=11;/*S11-function*/break;
               case 0xFD:number=10;/*S10-function*/break;
               case 0xFB:number=9;/*S9-function*/break;
               case 0xF7:number=8;/*S8-function*/break;
            }
            while(temp!=0x0F)					//松手检测
            {
                temp=P3;
                temp=temp&0x0F;
            }
        }
    }
		
	P3=0xDF;P4=0XFF;
	temp=P3;
    temp=temp&0x0F;
    if(temp!=0x0F)
    {
        delay(5);
        temp=P3;
        temp=temp&0x0F;
        if(temp!=0x0f)
        {
            temp=P3;
            switch(temp)
            {
               case 0xDE:number=15;/*S15-function*/break;
               case 0xDD:number=14;/*S14-function*/break;
               case 0xDB:number=13;/*S13-function*/break;
               case 0xD7:number=12;/*S12-function*/break;
            }
            while(temp!=0x0F)					//松手检测
            {
                temp=P3;
                temp=temp&0x0F;
            }
        }
    }
		
	P3=0xEF;P4=0XFF;
	temp=P3;
    temp=temp&0x0F;
    if(temp!=0x0F)
    {
        delay(5);
        temp=P3;
        temp=temp&0x0F;
        if(temp!=0x0f)
        {
            temp=P3;
            switch(temp)
            {
               case 0xEE:number=19;/*S19-function*/break;
               case 0xED:number=18;/*S18-function*/break;
               case 0xEB:number=17;/*S17-function*/break;
               case 0xE7:number=16;/*S16-function*/break;
            }
            while(temp!=0x0F)					//松手检测
            {
                temp=P3;
                temp=temp&0x0F;
            }
        }
    }
}

void display1(uchar one,uchar two)
{
    wei_control;
    P0=0x01;		//选中第一个数码管
    duan_control;
    P0=duanma[one];//给第一个数码管赋段码值
    delay(1);		//点亮1ms
    wei_control;
    P0=0x02;		//选中第二个数码管
    duan_control;
    P0=duanma[two];//给第二个数码管赋段码值
    delay(1);		//点亮1ms
}

void delay(uint xms)//毫秒级延时，传入参数5则延时5ms，没有定时器准，一般用于数码管以及IIC连续调用之中。
{
    uint i,j;
    for(i=xms;i>0;i--)
        for(j=845;j>0;j--);
}

void init(void)
{
    control;
    P0=0x00;	//关闭蜂鸣器&继电器
    wei_control;
    P0=0xFF;	//选中所有数码管
    duan_control;
    P0=0xFF;	//关闭所有数码管
    led_control;
    P0=0xFF;	//关闭所有LED
}
```

## 3、独立按键控制LED<span name = "supplement3"></span>

```c
//使用独立按键s7~s4控制LED的L1~L4
#include <STC15F2K60S2.h>
#include <intrins.h>

#define uchar unsigned char
#define uint unsigned int
	
#define control P2|=0XA0;P2&=0XBF;
#define wei_control P2|=0xC0;P2&=0xDF;
#define duan_control P2|=0xE0;P2&=0xFF;
#define led_control P2|=0x80;P2&=0x9F;

bit S7_down=0;S6_down=0;S5_down=0;S4_down=0;

void delay(uint xms);
void init(void);
void keyscanf(void);

void main(void)
{
	init();
	while(1)
	{
		

		keyscanf();
	}
}

void keyscanf(void)				//本函数中所有延时的作用均为消抖
{
    if(P30==0)
    {
        delay(5);
        if(P30==0)
        {
            S7_down=1;			//判定S7按下
        }
    }
    else if(P31==0)
    {
        delay(5);
        if(P31==0)
        {
            S6_down=1;			//判定S6按下
        }
    }
		else if(P32==0)
    {
        delay(5);
        if(P32==0)
        {
            S5_down=1;			
        }
    }
		else if(P33==0)
    {
        delay(5);
        if(P33==0)
        {
            S4_down=1;			
        }
    }
    if((S7_down==1)&&(P30==1))	//判定S7按下过，并已松开
    {
        delay(5);
        if(P30==1)
        {
            S7_down=0;			//恢复S7按下标志位
            led_control;
						P0=0xFE;
        }
    }
    else if((S6_down==1)&&(P31==1))
    {
        delay(5);
        if(P31==1)
        {
            S6_down=0;			//恢复S6按下标志位
            led_control;
						P0=0xFD;
        }
    }
		else if((S5_down==1)&&(P32==1))
    {
        delay(5);
        if(P32==1)
        {
            S5_down=0;			
            led_control;
						P0=0xFB;
        }
    }
		else if((S4_down==1)&&(P33==1))
    {
        delay(5);
        if(P33==1)
        {
            S4_down=0;			
            led_control;
						P0=0xF7;
        }
    }
}

void delay(uint xms)//毫秒级延时，传入参数5则延时5ms，没有定时器准，一般用于数码管以及IIC连续调用之中。
{
    uint i,j;
    for(i=xms;i>0;i--)
        for(j=845;j>0;j--);
}

void init(void)
{
    control;
    P0=0x00;	//关闭蜂鸣器&继电器
    wei_control;
    P0=0xFF;	//选中所有数码管
    duan_control;
    P0=0xFF;	//关闭所有数码管
    led_control;
    P0=0xFF;	//关闭所有LED
}
```

## 4、温度测量及显示<span name = "supplement4"></span>

```c
//测量温度，并使用第1、2位数码管显示
#include <STC15F2K60S2.h>
#include <intrins.h>

#define uchar unsigned char
#define uint unsigned int
	
#define control P2|=0XA0;P2&=0XBF;
#define wei_control P2|=0xC0;P2&=0xDF;
#define duan_control P2|=0xE0;P2&=0xFF;
#define led_control P2|=0x80;P2&=0x9F;

uchar code duanma[]={0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90,0xBF,0xFF};

uchar one,two,three,four,five,six,seven,eight;

sbit DQ = P1^4;  //单总线接口

void delay(uint xms);
void init(void);
void display1(uchar one,uchar two);
uchar ds18b20_get(void);

uchar wendu;

void main(void)
{
	init();
	while(1)
	{
		wendu=ds18b20_get();
		one=wendu/10;two=wendu%10;
		display1(one,two);
	}
}

//单总线延时函数
void Delay_OneWire(unsigned int t)  //STC89C52RC
{
	while(t--);
}

//通过单总线向DS18B20写一个字节
void Write_DS18B20(unsigned char dat)
{
	unsigned char i;
	for(i=0;i<8;i++)
	{
		DQ = 0;
		DQ = dat&0x01;
		Delay_OneWire(40);
		DQ = 1;
		dat >>= 1;
	}
	Delay_OneWire(40);
}

//从DS18B20读取一个字节
unsigned char Read_DS18B20(void)
{
	unsigned char i;
	unsigned char dat;
  
	for(i=0;i<8;i++)
	{
		DQ = 0;
		dat >>= 1;
		DQ = 1;
		if(DQ)
		{
			dat |= 0x80;
		}	    
		Delay_OneWire(40);
	}
	return dat;
}

//DS18B20设备初始化
bit init_ds18b20(void)
{
  	bit initflag = 0;
  	
  	DQ = 1;
  	Delay_OneWire(96);
  	DQ = 0;
  	Delay_OneWire(640);
  	DQ = 1;
  	Delay_OneWire(80); 
    initflag = DQ;     
  	Delay_OneWire(40);
  
  	return initflag;
}

uchar ds18b20_get(void)
{
    uchar temp;
    uchar low,high;
    init_ds18b20();
		Write_DS18B20(0xCC);	//无视64位ID序列码
		Write_DS18B20(0x44);	//温度转换指令
		Delay_OneWire(200);		//等待温度转换完成
		init_ds18b20();
		Write_DS18B20(0xCC);
		Write_DS18B20(0xBE);	//读取温度数值
		low=Read_DS18B20();
		high=Read_DS18B20();
		temp=high<<4;			//舍弃高四位（正负值）
		temp|=(low>>4);			//舍弃第四位（小数部分）
		return temp;
}

void display1(uchar one,uchar two)
{
    wei_control;
    P0=0x01;		//选中第一个数码管
    duan_control;
    P0=duanma[one];//给第一个数码管赋段码值
    delay(1);		//点亮1ms
    wei_control;
    P0=0x02;		//选中第二个数码管
    duan_control;
    P0=duanma[two];//给第二个数码管赋段码值
    delay(1);		//点亮1ms
}

void delay(uint xms)//毫秒级延时，传入参数5则延时5ms，没有定时器准，一般用于数码管以及IIC连续调用之中。
{
    uint i,j;
    for(i=xms;i>0;i--)
        for(j=845;j>0;j--);
}

void init(void)
{
    control;
    P0=0x00;	//关闭蜂鸣器&继电器
    wei_control;
    P0=0xFF;	//选中所有数码管
    duan_control;
    P0=0xFF;	//关闭所有数码管
    led_control;
    P0=0xFF;	//关闭所有LED
}
```

## 5、A/D转换及显示<span name = "supplement5"></span>

```c
//读取Rb2电压值或光敏电阻分压后电压值（下简称光敏值），使用第1~4位数码管显示，精度0.001
#include <STC15F2K60S2.h>
#include <intrins.h>

#define uchar unsigned char
#define uint unsigned int
	
#define control P2|=0XA0;P2&=0XBF;
#define wei_control P2|=0xC0;P2&=0xDF;
#define duan_control P2|=0xE0;P2&=0xFF;
#define led_control P2|=0x80;P2&=0x9F;

#define DELAY_TIME 40

//总线引脚定义
sbit SDA = P2^1;  /* 数据线 */
sbit SCL = P2^0;  /* 时钟线 */

uchar code duanma[]={0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90,0xBF,0xFF};

uchar one,two,three,four,five,six,seven,eight;

void delay(uint xms);
void init(void);
void display1(uchar one,uchar two);
void display2(uchar three,uchar four);
uchar IIC_AD_read(uchar add);
uint volt;

void main(void)
{
	init();
	while(1)
	{
		volt=IIC_AD_read(0x03)*19.6; //读取Rb2电压值，读取光敏值时请注释此行
//		volt=IIC_AD_read(0x01)*19.6; //读取光敏值，读取Rb2电压值时请注释此行	
		one=volt/1000;two=volt%1000/100;three=volt%100/10;four=volt%10;
		
		display1(one,two);
		display2(three,four);
	}
}

void IIC_Delay(unsigned char i)
{
    do{_nop_();}
    while(i--);        
}
//总线启动条件
void IIC_Start(void)
{
    SDA = 1;
    SCL = 1;
    IIC_Delay(DELAY_TIME);
    SDA = 0;
    IIC_Delay(DELAY_TIME);
    SCL = 0;	
}

//总线停止条件
void IIC_Stop(void)
{
    SDA = 0;
    SCL = 1;
    IIC_Delay(DELAY_TIME);
    SDA = 1;
    IIC_Delay(DELAY_TIME);
}

//等待应答
bit IIC_WaitAck(void)
{
    bit ackbit;
	
    SCL  = 1;
    IIC_Delay(DELAY_TIME);
    ackbit = SDA;
    SCL = 0;
    IIC_Delay(DELAY_TIME);
    return ackbit;
}

//通过I2C总线发送数据
void IIC_SendByte(unsigned char byt)
{
    unsigned char i;

    for(i=0; i<8; i++)
    {
        SCL  = 0;
        IIC_Delay(DELAY_TIME);
        if(byt & 0x80) SDA  = 1;
        else SDA  = 0;
        IIC_Delay(DELAY_TIME);
        SCL = 1;
        byt <<= 1;
        IIC_Delay(DELAY_TIME);
    }
    SCL  = 0;  
}

//从I2C总线上接收数据
unsigned char IIC_RecByte(void)
{
    unsigned char i, da;
    for(i=0; i<8; i++)
    {   
    	SCL = 1;
	IIC_Delay(DELAY_TIME);
	da <<= 1;
	if(SDA) da |= 1;
	SCL = 0;
	IIC_Delay(DELAY_TIME);
    }
    return da;    
}

uchar IIC_AD_read(uchar add)
{
	uchar data_AD;
	IIC_Start();
	IIC_SendByte(0x90);		//cmd write
	IIC_WaitAck();
	IIC_SendByte(add);		//RB2：0x03;光敏：0x01;
	IIC_WaitAck();
	IIC_Stop();

	IIC_Start();
	IIC_SendByte(0x91);		//cmd read
	IIC_WaitAck();
	data_AD=IIC_RecByte();
	IIC_Stop();
	return data_AD;
}

void display1(uchar one,uchar two)
{
    wei_control;
    P0=0x01;		//选中第一个数码管
    duan_control;
    P0=duanma[one];//给第一个数码管赋段码值
    delay(1);		//点亮1ms
    wei_control;
    P0=0x02;		//选中第二个数码管
    duan_control;
    P0=duanma[two];//给第二个数码管赋段码值
    delay(1);		//点亮1ms
}

void display2(uchar three,uchar four)
{
    wei_control;
    P0=0x04;		//选中第一个数码管
    duan_control;
    P0=duanma[three];//给第一个数码管赋段码值
    delay(1);		//点亮1ms
    wei_control;
    P0=0x08;		//选中第二个数码管
    duan_control;
    P0=duanma[four];//给第二个数码管赋段码值
    delay(1);		//点亮1ms
}

void delay(uint xms)//毫秒级延时，传入参数5则延时5ms，没有定时器准，一般用于数码管以及IIC连续调用之中。
{
    uint i,j;
    for(i=xms;i>0;i--)
        for(j=845;j>0;j--);
}

void init(void)
{
    control;
    P0=0x00;	//关闭蜂鸣器&继电器
    wei_control;
    P0=0xFF;	//选中所有数码管
    duan_control;
    P0=0xFF;	//关闭所有数码管
    led_control;
    P0=0xFF;	//关闭所有LED
}
```

## 6、D/A输出<span name = "supplement6"></span>

```c
//D/A输出约2V电压，测量引脚在竞赛板右侧的'D/A'排针
#include <STC15F2K60S2.h>
#include <intrins.h>

#define uchar unsigned char
#define uint unsigned int
	
#define control P2|=0XA0;P2&=0XBF;
#define wei_control P2|=0xC0;P2&=0xDF;
#define duan_control P2|=0xE0;P2&=0xFF;
#define led_control P2|=0x80;P2&=0x9F;

#define DELAY_TIME 40

//总线引脚定义
sbit SDA = P2^1;  /* 数据线 */
sbit SCL = P2^0;  /* 时钟线 */

void init(void);
void IIC_DA_out(uchar dat);

void main(void)
{
	init();
	while(1)
	{
		IIC_DA_out(102);
	}
}

void IIC_Delay(unsigned char i)
{
    do{_nop_();}
    while(i--);        
}
//总线启动条件
void IIC_Start(void)
{
    SDA = 1;
    SCL = 1;
    IIC_Delay(DELAY_TIME);
    SDA = 0;
    IIC_Delay(DELAY_TIME);
    SCL = 0;	
}

//总线停止条件
void IIC_Stop(void)
{
    SDA = 0;
    SCL = 1;
    IIC_Delay(DELAY_TIME);
    SDA = 1;
    IIC_Delay(DELAY_TIME);
}

//等待应答
bit IIC_WaitAck(void)
{
    bit ackbit;
	
    SCL  = 1;
    IIC_Delay(DELAY_TIME);
    ackbit = SDA;
    SCL = 0;
    IIC_Delay(DELAY_TIME);
    return ackbit;
}

//通过I2C总线发送数据
void IIC_SendByte(unsigned char byt)
{
    unsigned char i;

    for(i=0; i<8; i++)
    {
        SCL  = 0;
        IIC_Delay(DELAY_TIME);
        if(byt & 0x80) SDA  = 1;
        else SDA  = 0;
        IIC_Delay(DELAY_TIME);
        SCL = 1;
        byt <<= 1;
        IIC_Delay(DELAY_TIME);
    }
    SCL  = 0;  
}

void IIC_DA_out(uchar dat)
{
	IIC_Start();
	IIC_SendByte(0x90);		//cmd write
	IIC_WaitAck();
	IIC_SendByte(0x40);		//cmd ANALOGUE OUTPUT ENABLE
	IIC_WaitAck();
	IIC_SendByte(dat);
	IIC_WaitAck();
	IIC_Stop();
}

void init(void)
{
    control;
    P0=0x00;	//关闭蜂鸣器&继电器
    wei_control;
    P0=0xFF;	//选中所有数码管
    duan_control;
    P0=0xFF;	//关闭所有数码管
    led_control;
    P0=0xFF;	//关闭所有LED
}
```

## 7、EEPROM读写<span name = "supplement7"></span>

```c
//使用独立按键控制EEPROM读写1字节数据，以及控制数据加减。
//S7:数据数值加1；S6数据数值减1；S5：从地址0x70中读取数值赋给数据；S4：向地址0x70写入数据当前数值。
//数据数值默认为5。
#include <STC15F2K60S2.h>
#include <intrins.h>

#define uchar unsigned char
#define uint unsigned int
	
#define control P2|=0XA0;P2&=0XBF;
#define wei_control P2|=0xC0;P2&=0xDF;
#define duan_control P2|=0xE0;P2&=0xFF;
#define led_control P2|=0x80;P2&=0x9F;

#define DELAY_TIME 40

uchar code duanma[]={0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90,0xBF,0xFF};

uchar one,two,three,four,five,six,seven,eight;

//总线引脚定义
sbit SDA = P2^1;  /* 数据线 */
sbit SCL = P2^0;  /* 时钟线 */

bit S7_down=0;S6_down=0;S5_down=0;S4_down=0;

void delay(uint xms);
void init(void);
void display1(uchar one,uchar two);
void keyscanf(void);
uchar IIC_EEPROM_READ(uchar add);
void IIC_EEPROM_WRITE(uchar add,uchar dat);
uchar number=5;

void main(void)
{
	init();
	while(1)
	{
		one=number/10;two=number%10;
		display1(one,two);
		keyscanf();
	}
}

void keyscanf(void)				//本函数中所有延时的作用均为消抖
{
    if(P30==0)
    {
        delay(5);
        if(P30==0)
        {
            S7_down=1;			//判定S7按下
        }
    }
    else if(P31==0)
    {
        delay(5);
        if(P31==0)
        {
            S6_down=1;			//判定S6按下
        }
    }
		else if(P32==0)
    {
        delay(5);
        if(P32==0)
        {
            S5_down=1;			
        }
    }
		else if(P33==0)
    {
        delay(5);
        if(P33==0)
        {
            S4_down=1;			
        }
    }
    if((S7_down==1)&&(P30==1))	//判定S7按下过，并已松开
    {
        delay(5);
        if(P30==1)
        {
            S7_down=0;			//恢复S7按下标志位
            number=number+1;
						if(number==100)
							number=0;
        }
    }
    else if((S6_down==1)&&(P31==1))
    {
        delay(5);
        if(P31==1)
        {
            S6_down=0;			//恢复S6按下标志位
            number=number-1;
						if(number==255)		//uchar变量为0后再减1会变为255
							number=99;
        }
    }
		else if((S5_down==1)&&(P32==1))
    {
        delay(5);
        if(P32==1)
        {
           S5_down=0;
					number=IIC_EEPROM_READ(0x70);delay(5);
        }
    }
		else if((S4_down==1)&&(P33==1))
    {
        delay(5);
        if(P33==1)
        {
            S4_down=0;			
            IIC_EEPROM_WRITE(0x70,number);delay(5);
        }
    }
}

void IIC_Delay(unsigned char i)
{
    do{_nop_();}
    while(i--);        
}
//总线启动条件
void IIC_Start(void)
{
    SDA = 1;
    SCL = 1;
    IIC_Delay(DELAY_TIME);
    SDA = 0;
    IIC_Delay(DELAY_TIME);
    SCL = 0;	
}

//总线停止条件
void IIC_Stop(void)
{
    SDA = 0;
    SCL = 1;
    IIC_Delay(DELAY_TIME);
    SDA = 1;
    IIC_Delay(DELAY_TIME);
}

//等待应答
bit IIC_WaitAck(void)
{
    bit ackbit;
	
    SCL  = 1;
    IIC_Delay(DELAY_TIME);
    ackbit = SDA;
    SCL = 0;
    IIC_Delay(DELAY_TIME);
    return ackbit;
}

//通过I2C总线发送数据
void IIC_SendByte(unsigned char byt)
{
    unsigned char i;

    for(i=0; i<8; i++)
    {
        SCL  = 0;
        IIC_Delay(DELAY_TIME);
        if(byt & 0x80) SDA  = 1;
        else SDA  = 0;
        IIC_Delay(DELAY_TIME);
        SCL = 1;
        byt <<= 1;
        IIC_Delay(DELAY_TIME);
    }
    SCL  = 0;  
}

//从I2C总线上接收数据
unsigned char IIC_RecByte(void)
{
    unsigned char i, da;
    for(i=0; i<8; i++)
    {   
    	SCL = 1;
	IIC_Delay(DELAY_TIME);
	da <<= 1;
	if(SDA) da |= 1;
	SCL = 0;
	IIC_Delay(DELAY_TIME);
    }
    return da;    
}

void IIC_EEPROM_WRITE(uchar add,uchar dat)
{
	IIC_Start();
	IIC_SendByte(0xA0);		//cmd write
	IIC_WaitAck();
	IIC_SendByte(add);		//要写入的地址
	IIC_WaitAck();
	IIC_SendByte(dat);		//要写入的数据
	IIC_WaitAck();
	IIC_Stop();
}

uchar IIC_EEPROM_READ(uchar add)
{
	uchar dat;
	IIC_Start();
	IIC_SendByte(0xA0);		//cmd write
	IIC_WaitAck();
	IIC_SendByte(add);		//要读取的地址
	IIC_WaitAck();
	IIC_Stop();
	
	IIC_Start();
	IIC_SendByte(0xA1);		//cmd read
	IIC_WaitAck();
	dat=IIC_RecByte();		//读出数据
	IIC_Stop();
	return dat;
}

void display1(uchar one,uchar two)
{
    wei_control;
    P0=0x01;		//选中第一个数码管
    duan_control;
    P0=duanma[one];//给第一个数码管赋段码值
    delay(1);		//点亮1ms
    wei_control;
    P0=0x02;		//选中第二个数码管
    duan_control;
    P0=duanma[two];//给第二个数码管赋段码值
    delay(1);		//点亮1ms
}

void delay(uint xms)//毫秒级延时，传入参数5则延时5ms，没有定时器准，一般用于数码管以及IIC连续调用之中。
{
    uint i,j;
    for(i=xms;i>0;i--)
        for(j=845;j>0;j--);
}

void init(void)
{
    control;
    P0=0x00;	//关闭蜂鸣器&继电器
    wei_control;
    P0=0xFF;	//选中所有数码管
    duan_control;
    P0=0xFF;	//关闭所有数码管
    led_control;
    P0=0xFF;	//关闭所有LED
}
```

## 8、时钟芯片应用<span name = "supplement8"></span>

```c
#include <STC15F2K60S2.h>
#include <intrins.h>

#define uchar unsigned char
#define uint unsigned int
	
#define control P2|=0XA0;P2&=0XBF;
#define wei_control P2|=0xC0;P2&=0xDF;
#define duan_control P2|=0xE0;P2&=0xFF;
#define led_control P2|=0x80;P2&=0x9F;

sbit SCLK=P1^7;		
sbit IO=P2^3;		
sbit CE = P1^3;   // DS1302复位

uchar code duanma[]={0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90,0xBF,0xFF};

uchar one,two,three,four,five,six,seven,eight;

uchar time[7]={55,59,23,0,0,0,0}; //初始化时间为23:59:55，后四位分别为日（1-31），月（1-12），周（1-7），年（00-99）
													//详细查阅官方资源包中竞赛板芯片资料DS1302第9页

void delay(uint xms);
void init(void);
void display1(uchar one,uchar two);
void display2(uchar three,uchar four);
void display3(uchar five,uchar six);
void display4(uchar seven,uchar eight);
void DS1302_init(void);
void DS1302_timeget(void);

void main(void)
{
	init();
	DS1302_init();				//写入初始化时间参数
	while(1)
	{
		DS1302_timeget();
		one=time[2]/10;two=time[2]%10;		//小时
		three=10;													//间隔符'-'
		four=time[1]/10;five=time[1]%10;	//分钟
		six=10;														//间隔符'-'
		seven=time[0]/10;eight=time[0]%10;//秒
		display1(one,two);
		display2(three,four);
		display3(five,six);
		display4(seven,eight);
	}
}

void Write_Ds1302(unsigned  char temp) 
{
	unsigned char i;
	for (i=0;i<8;i++)     	
	{ 
		SCLK=0;
		IO=temp&0x01;
		SCLK=1;
		temp>>=1; 
	}
}   

void Write_Ds1302_Byte( unsigned char address,unsigned char dat )     
{
	uchar temp;
 	CE=0;
 	SCLK=0;
 	CE=1;
 	Write_Ds1302(address);
	temp=(dat/10<<4)|(dat%10);
 	Write_Ds1302(temp);		
 	CE=0; 
}

unsigned char Read_Ds1302_Byte ( unsigned char address )
{
 	unsigned char i,temp=0x00;
	uchar dat1,dat2;
 	CE=0;
 	SCLK=0;
 	CE=1;
 	Write_Ds1302(address);
 	for (i=0;i<8;i++) 	
 	{		
		SCLK=0;
		temp>>=1;	
 		if(IO)
 		temp|=0x80;	
 		SCLK=1;
	} 
	IO=0;
	dat1=temp/16;		
  	dat2=temp%16;
  	temp=dat1*10+dat2;		//对返回值进行调整
	return (temp);	
}

void DS1302_init(void)
{
    uchar add=0x80,i;
    Write_Ds1302_Byte(0x8E,0x00);		//关闭写保护
    for(i=0;i<7;i++)
    {
        Write_Ds1302_Byte(add,time[i]);	//数组time的释义见下面时钟芯片使用示例
        add=add+2;
    }
    Write_Ds1302_Byte(0x8E,0x80);		//打开写保护
}

void DS1302_timeget(void)
{
    uchar add=0x81,i;
    Write_Ds1302_Byte(0x8E,0x00);		//关闭写保护
    for(i=0;i<7;i++)
    {
        time[i]=Read_Ds1302_Byte(add); //读取各个时间参数值
        add=add+2;
    }
    Write_Ds1302_Byte(0x8E,0x80);		//打开写保护
}

void display1(uchar one,uchar two)
{
    wei_control;
    P0=0x01;		//选中第一个数码管
    duan_control;
    P0=duanma[one];//给第一个数码管赋段码值
    delay(1);		//点亮1ms
    wei_control;
    P0=0x02;		//选中第二个数码管
    duan_control;
    P0=duanma[two];//给第二个数码管赋段码值
    delay(1);		//点亮1ms
}

void display2(uchar three,uchar four)
{
    wei_control;
    P0=0x04;		//选中第一个数码管
    duan_control;
    P0=duanma[three];//给第一个数码管赋段码值
    delay(1);		//点亮1ms
    wei_control;
    P0=0x08;		//选中第二个数码管
    duan_control;
    P0=duanma[four];//给第二个数码管赋段码值
    delay(1);		//点亮1ms
}

void display3(uchar five,uchar six)
{
    wei_control;
    P0=0x10;		//选中第一个数码管
    duan_control;
    P0=duanma[five];//给第一个数码管赋段码值
    delay(1);		//点亮1ms
    wei_control;
    P0=0x20;		//选中第二个数码管
    duan_control;
    P0=duanma[six];//给第二个数码管赋段码值
    delay(1);		//点亮1ms
}

void display4(uchar seven,uchar eight)
{
    wei_control;
    P0=0x40;		//选中第一个数码管
    duan_control;
    P0=duanma[seven];//给第一个数码管赋段码值
    delay(1);		//点亮1ms
    wei_control;
    P0=0x80;		//选中第二个数码管
    duan_control;
    P0=duanma[eight];//给第二个数码管赋段码值
    delay(1);		//点亮1ms
}

void delay(uint xms)//毫秒级延时，传入参数5则延时5ms，没有定时器准，一般用于数码管以及IIC连续调用之中。
{
    uint i,j;
    for(i=xms;i>0;i--)
        for(j=845;j>0;j--);
}

void init(void)
{
    control;
    P0=0x00;	//关闭蜂鸣器&继电器
    wei_control;
    P0=0xFF;	//选中所有数码管
    duan_control;
    P0=0xFF;	//关闭所有数码管
    led_control;
    P0=0xFF;	//关闭所有LED
}
```

## 9、使用定时器消隐的A/D转换及显示<span name = "supplement9"></span>

```c
//读取Rb2电压值或光敏电阻分压后电压值（下简称光敏值），使用第1~4位数码管显示，精度0.001
#include <STC15F2K60S2.h>
#include <intrins.h>

#define uchar unsigned char
#define uint unsigned int
	
#define control P2|=0XA0;P2&=0XBF;
#define wei_control P2|=0xC0;P2&=0xDF;
#define duan_control P2|=0xE0;P2&=0xFF;
#define led_control P2|=0x80;P2&=0x9F;

#define DELAY_TIME 40

//总线引脚定义
sbit SDA = P2^1;  /* 数据线 */
sbit SCL = P2^0;  /* 时钟线 */

uchar code duanma[]={0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90,0xBF,0xFF};

uchar display[8]={1,2,3,4,5,6,7,8};//此数组下标0~7分别对应第1~8位数码管。
uchar discount=0;					//用于计数点亮到第几个数码管

void delay(uint xms);
void init(void);
uchar IIC_AD_read(uchar add);
void Timer2Init(void);
uint volt;

void main(void)
{
	init();
	Timer2Init();
	while(1)
	{
		volt=IIC_AD_read(0x03)*19.6; //读取Rb2电压值，读取光敏值时请注释此行
//		volt=IIC_AD_read(0x01)*19.6; //读取光敏值，读取Rb2电压值时请注释此行	
		
		display[0]=volt/1000;display[1]=volt%1000/100;display[2]=volt%100/10;display[3]=volt%10;
		display[4]=11;display[5]=11;display[6]=11;display[7]=11;//关闭未使用到的数码管
	}
}

void Timer2Init(void)		//1毫秒@12.000MHz
{
	AUXR |= 0x04;		//定时器时钟1T模式
	T2L = 0x20;		//设置定时初值
	T2H = 0xD1;		//设置定时初值
	AUXR |= 0x10;		//定时器2开始计时
    IE2 |= 0x04;	//开启定时器2中断
    EA = 1;			//打开总中断
}

void tim2_isr() interrupt 12 //定时器2的中断服务号为12
{
    wei_control;
    P0=(1<<discount);			//0000 0001→0000 0010以此类推
    duan_control;
    P0=duanma[display[discount]];	//段码
    if(++discount==8)discount=0;//计数值清零，以重新从第一位数码管开始
}

void IIC_Delay(unsigned char i)
{
    do{_nop_();}
    while(i--);        
}
//总线启动条件
void IIC_Start(void)
{
    SDA = 1;
    SCL = 1;
    IIC_Delay(DELAY_TIME);
    SDA = 0;
    IIC_Delay(DELAY_TIME);
    SCL = 0;	
}

//总线停止条件
void IIC_Stop(void)
{
    SDA = 0;
    SCL = 1;
    IIC_Delay(DELAY_TIME);
    SDA = 1;
    IIC_Delay(DELAY_TIME);
}

//等待应答
bit IIC_WaitAck(void)
{
    bit ackbit;
	
    SCL  = 1;
    IIC_Delay(DELAY_TIME);
    ackbit = SDA;
    SCL = 0;
    IIC_Delay(DELAY_TIME);
    return ackbit;
}

//通过I2C总线发送数据
void IIC_SendByte(unsigned char byt)
{
    unsigned char i;

    for(i=0; i<8; i++)
    {
        SCL  = 0;
        IIC_Delay(DELAY_TIME);
        if(byt & 0x80) SDA  = 1;
        else SDA  = 0;
        IIC_Delay(DELAY_TIME);
        SCL = 1;
        byt <<= 1;
        IIC_Delay(DELAY_TIME);
    }
    SCL  = 0;  
}

//从I2C总线上接收数据
unsigned char IIC_RecByte(void)
{
    unsigned char i, da;
    for(i=0; i<8; i++)
    {   
    	SCL = 1;
	IIC_Delay(DELAY_TIME);
	da <<= 1;
	if(SDA) da |= 1;
	SCL = 0;
	IIC_Delay(DELAY_TIME);
    }
    return da;    
}

uchar IIC_AD_read(uchar add)
{
	uchar data_AD;
	IIC_Start();
	IIC_SendByte(0x90);		//cmd write
	IIC_WaitAck();
	IIC_SendByte(add);		//RB2：0x03;光敏：0x01;
	IIC_WaitAck();
	IIC_Stop();

	IIC_Start();
	IIC_SendByte(0x91);		//cmd read
	IIC_WaitAck();
	data_AD=IIC_RecByte();
	IIC_Stop();
	return data_AD;
}

void delay(uint xms)//毫秒级延时，传入参数5则延时5ms，没有定时器准，一般用于数码管以及IIC连续调用之中。
{
    uint i,j;
    for(i=xms;i>0;i--)
        for(j=845;j>0;j--);
}

void init(void)
{
    control;
    P0=0x00;	//关闭蜂鸣器&继电器
    wei_control;
    P0=0xFF;	//选中所有数码管
    duan_control;
    P0=0xFF;	//关闭所有数码管
    led_control;
    P0=0xFF;	//关闭所有LED
}
```

## 10、独立按键-按下松开切换界面<span name = "supplement10"></span>

```c
#include <STC15F2K60S2.h>
#include <intrins.h>

#define uchar unsigned char
#define uint unsigned int
	
#define control P2|=0XA0;P2&=0XBF;
#define wei_control P2|=0xC0;P2&=0xDF;
#define duan_control P2|=0xE0;P2&=0xFF;
#define led_control P2|=0x80;P2&=0x9F;

bit S7_down=0;S6_down=0;S5_down=0;S4_down=0;

uchar code duanma[]={0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90,0xBF,0xFF};

uchar display[8]={1,2,3,4,5,6,7,8};//此数组下标0~7分别对应第1~8位数码管。
uchar discount=0;					//用于计数点亮到第几个数码管

void Timer2Init(void);
void keyscanf(void);
void init(void);
void delay(uint xms);

uchar number=7;
uchar dis_flag=0;

void main(void)
{
	init();
	Timer2Init();
	while(1)
	{
		if(dis_flag==1)
		{
			number=70;
		}
		else 
		{
			number=7;
		}
		display[0]=number/10;display[1]=number%10;
		display[2]=11;display[3]=11;display[4]=11;display[5]=11;display[6]=11;display[7]=11;
	
		keyscanf();
	}
}

void keyscanf(void)				//本函数中所有延时的作用均为消抖
{
    if(P30==0)
    {
        delay(5);
        if(P30==0)
        {
            S7_down=1;			//判定S7按下
			dis_flag=1;
        }
    }
    if((S7_down==1)&&(P30==1))	//判定S7按下过，并已松开
    {
        delay(5);
        if(P30==1)
        {
            S7_down=0;		//恢复S7按下标志位
			dis_flag=0;		//恢复显示界面标志位
        }
    }
}

void Timer2Init(void)		//1毫秒@12.000MHz
{
	AUXR |= 0x04;		//定时器时钟1T模式
	T2L = 0x20;		//设置定时初值
	T2H = 0xD1;		//设置定时初值
	AUXR |= 0x10;		//定时器2开始计时
    IE2 |= 0x04;	//开启定时器2中断
    EA = 1;			//打开总中断
}

void tim2_isr() interrupt 12 //定时器2的中断服务号为12
{
    wei_control;
    P0=(1<<discount);			//0000 0001→0000 0010以此类推
    duan_control;
    P0=duanma[display[discount]];	//段码
    if(++discount==8)discount=0;//计数值清零，以重新从第一位数码管开始
}

void delay(uint xms)//毫秒级延时，传入参数5则延时5ms，没有定时器准，一般用于数码管以及IIC连续调用之中。
{
    uint i,j;
    for(i=xms;i>0;i--)
        for(j=845;j>0;j--);
}

void init(void)
{
    control;
    P0=0x00;	//关闭蜂鸣器&继电器
    wei_control;
    P0=0xFF;	//选中所有数码管
    duan_control;
    P0=0xFF;	//关闭所有数码管
    led_control;
    P0=0xFF;	//关闭所有LED
}
```



## 11、独立按键-长按累加<span name = "supplement11"></span>

```c
//轻微复杂优美法下的长按累加
#include <STC15F2K60S2.h>
#include <intrins.h>

#define uchar unsigned char
#define uint unsigned int
	
#define control P2|=0XA0;P2&=0XBF;
#define wei_control P2|=0xC0;P2&=0xDF;
#define duan_control P2|=0xE0;P2&=0xFF;
#define led_control P2|=0x80;P2&=0x9F;

bit S7_down=0;S6_down=0;S5_down=0;S4_down=0;

uchar code duanma[]={0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90,0xBF,0xFF};

uchar display[8]={1,2,3,4,5,6,7,8};//此数组下标0~7分别对应第1~8位数码管。
uchar discount=0;					//用于计数点亮到第几个数码管

void Timer2Init(void);
void keyscanf(void);
void init(void);
void delay(uint xms);

uchar number=5;
uchar S7_time=0;
void main(void)
{
	init();
	Timer2Init();
	while(1)
	{
		display[0]=number/10;display[1]=number%10;
		display[2]=11;display[3]=11;display[4]=11;display[5]=11;display[6]=11;display[7]=11;
        
		keyscanf();
	}
}

void keyscanf(void)				//本函数中所有延时的作用均为消抖
{
    if(P30==0)
    {
        delay(5);
        if(P30==0)
        {
            S7_down=1;			//判定S7按下
			while(!P30)
			{
				delay(100);				
				if(++S7_time>=8)	//按下时间超过800ms判定为长按成功
				{
					S7_time=0;
					number++;
					if(number==100)
					number=0;
					break;			//跳出循环以显示
				}
			}
        }
    }
    if((S7_down==1)&&(P30==1))	//判定S7按下过，并已松开
    {
        delay(5);
        if(P30==1)
        {
            S7_down=0;S7_time=0;			//恢复S7按下标志位
        }
    }
}

void Timer2Init(void)		//1毫秒@12.000MHz
{
	AUXR |= 0x04;		//定时器时钟1T模式
	T2L = 0x20;		//设置定时初值
	T2H = 0xD1;		//设置定时初值
	AUXR |= 0x10;		//定时器2开始计时
    IE2 |= 0x04;	//开启定时器2中断
    EA = 1;			//打开总中断
}

void tim2_isr() interrupt 12 //定时器2的中断服务号为12
{
    wei_control;
    P0=(1<<discount);			//0000 0001→0000 0010以此类推
    duan_control;
    P0=duanma[display[discount]];	//段码
    if(++discount==8)discount=0;//计数值清零，以重新从第一位数码管开始
}

void delay(uint xms)//毫秒级延时，传入参数5则延时5ms，没有定时器准，一般用于数码管以及IIC连续调用之中。
{
    uint i,j;
    for(i=xms;i>0;i--)
        for(j=845;j>0;j--);
}

void init(void)
{
    control;
    P0=0x00;	//关闭蜂鸣器&继电器
    wei_control;
    P0=0xFF;	//选中所有数码管
    duan_control;
    P0=0xFF;	//关闭所有数码管
    led_control;
    P0=0xFF;	//关闭所有LED
}
```

## 12、独立按键-双击<span name = "supplement12"></span>

```c
#include <STC15F2K60S2.h>
#include <intrins.h>

#define uchar unsigned char
#define uint unsigned int
	
#define control P2|=0XA0;P2&=0XBF;
#define wei_control P2|=0xC0;P2&=0xDF;
#define duan_control P2|=0xE0;P2&=0xFF;
#define led_control P2|=0x80;P2&=0x9F;

bit S7_down=0;S6_down=0;S5_down=0;S4_down=0;

uchar code duanma[]={0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90,0xBF,0xFF};

uchar display[8]={1,2,3,4,5,6,7,8};//此数组下标0~7分别对应第1~8位数码管。
uchar discount=0;					//用于计数点亮到第几个数码管

void Timer2Init(void);
void keyscanf(void);
void init(void);
void delay(uint xms);

uchar number=7;
uchar key_double=0;
void main(void)
{
	init();
	Timer2Init();
	while(1)
	{
		display[0]=number/10;display[1]=number%10;
		display[2]=11;display[3]=11;display[4]=11;display[5]=11;display[6]=11;display[7]=11;
	
		keyscanf();
	}
}

void keyscanf(void)				//本函数中所有延时的作用均为消抖
{
    if(P30==0)
    {
        delay(5);
        if(P30==0)
        {
            S7_down=1;			//判定S7按下
        }
    }
    if((S7_down==1)&&(P30==1))	//判定S7按下过，并已松开
    {
        delay(5);
        if(P30==1)
        {
            S7_down=0;		//恢复S7按下标志位
			if(key_double!=2)//对双击标志位进行判断
			{
				key_double++;
			}
			if(key_double==2)
			{
				key_double=0;//双击标志位清零
				number++;
				if(number==100)
					number=0;
			}
        }
    }
}

void Timer2Init(void)		//1毫秒@12.000MHz
{
	AUXR |= 0x04;		//定时器时钟1T模式
	T2L = 0x20;		//设置定时初值
	T2H = 0xD1;		//设置定时初值
	AUXR |= 0x10;		//定时器2开始计时
    IE2 |= 0x04;	//开启定时器2中断
    EA = 1;			//打开总中断
}

void tim2_isr() interrupt 12 //定时器2的中断服务号为12
{
    wei_control;
    P0=(1<<discount);			//0000 0001→0000 0010以此类推
    duan_control;
    P0=duanma[display[discount]];	//段码
    if(++discount==8)discount=0;//计数值清零，以重新从第一位数码管开始
}

void delay(uint xms)//毫秒级延时，传入参数5则延时5ms，没有定时器准，一般用于数码管以及IIC连续调用之中。
{
    uint i,j;
    for(i=xms;i>0;i--)
        for(j=845;j>0;j--);
}

void init(void)
{
    control;
    P0=0x00;	//关闭蜂鸣器&继电器
    wei_control;
    P0=0xFF;	//选中所有数码管
    duan_control;
    P0=0xFF;	//关闭所有数码管
    led_control;
    P0=0xFF;	//关闭所有LED
}

```

## 13、矩阵按键控制数码管-避开串口<span name = "supplement13"></span>

```c
#include <STC15F2K60S2.h>
#include <intrins.h>

#define uchar unsigned char
#define uint unsigned int
	
#define control P2|=0XA0;P2&=0XBF;
#define wei_control P2|=0xC0;P2&=0xDF;
#define duan_control P2|=0xE0;P2&=0xFF;
#define led_control P2|=0x80;P2&=0x9F;

bit S17_down=0;S16_down=0;S12_down=0;S13_down=0;S8_down=0;S9_down=0;S5_down=0;S4_down=0;

uchar code duanma[]={0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90,0xBF,0xFF};

uchar display[8]={1,2,3,4,5,6,7,8};//此数组下标0~7分别对应第1~8位数码管。
uchar discount=0;					//用于计数点亮到第几个数码管

void Timer2Init(void);
void keyscanf(void);
void init(void);
void delay(uint xms);

uchar number=7;
uchar key_double=0;
void main(void)
{
	init();
	Timer2Init();
	while(1)
	{
		display[0]=number/10;display[1]=number%10;
		display[2]=11;display[3]=11;display[4]=11;display[5]=11;display[6]=11;display[7]=11;
	
		keyscanf();
	}
}

void keyscanf(void)
{
	P34=0;P35=1;P42=1;P44=1;
	if(P32==0)
	{
		delay(5);
		if(P32==0)
		{
			S17_down=1;
		}
	}
	else if(P33==0)
	{
		delay(5);
		if(P33==0)
		{
			S16_down=1;
		}
	}
	if((S17_down==1)&&(P32==1))
	{
		delay(5);
		if(P32==1)
		{
			S17_down=0;
			number=17;
			//function
		}
	}
	else if((S16_down==1)&&(P33==1))
	{
		delay(5);
		if(P33==1)
		{
			S16_down=0;
			number=16;
			//function
		}
	}
	
	P34=1;P35=0;P42=1;P44=1;
	if(P32==0)
	{
		delay(5);
		if(P32==0)
		{
			S13_down=1;
		}
	}
	else if(P33==0)
	{
		delay(5);
		if(P33==0)
		{
			S12_down=1;
		}
	}
	if((S13_down==1)&&(P32==1))
	{
		delay(5);
		if(P32==1)
		{
			S13_down=0;
			number=13;
			//function
		}
	}
	else if((S12_down==1)&&(P33==1))
	{
		delay(5);
		if(P33==1)
		{
			S12_down=0;
			number=12;
			//function
		}
	}
	
	P34=1;P35=1;P42=0;P44=1;
	if(P32==0)
	{
		delay(5);
		if(P32==0)
		{
			S9_down=1;
		}
	}
	else if(P33==0)
	{
		delay(5);
		if(P33==0)
		{
			S8_down=1;
		}
	}
	if((S9_down==1)&&(P32==1))
	{
		delay(5);
		if(P32==1)
		{
			S9_down=0;
			number=9;
			//function
		}
	}
	else if((S8_down==1)&&(P33==1))
	{
		delay(5);
		if(P33==1)
		{
			S8_down=0;
			number=8;
			//function
		}
	}
	
	P34=1;P35=1;P42=1;P44=0;
	if(P32==0)
	{
		delay(5);
		if(P32==0)
		{
			S5_down=1;
		}
	}
	else if(P33==0)
	{
		delay(5);
		if(P33==0)
		{
			S4_down=1;
		}
	}
	if((S5_down==1)&&(P32==1))
	{
		delay(5);
		if(P32==1)
		{
			S5_down=0;
			number=5;
			//function
		}
	}
	else if((S4_down==1)&&(P33==1))
	{
		delay(5);
		if(P33==1)
		{
			S4_down=0;
			number=4;
			//function
		}
	}
}

void Timer2Init(void)		//1毫秒@12.000MHz
{
	AUXR |= 0x04;		//定时器时钟1T模式
	T2L = 0x20;		//设置定时初值
	T2H = 0xD1;		//设置定时初值
	AUXR |= 0x10;		//定时器2开始计时
    IE2 |= 0x04;	//开启定时器2中断
    EA = 1;			//打开总中断
}

void tim2_isr() interrupt 12 //定时器2的中断服务号为12
{
    wei_control;
    P0=(1<<discount);			//0000 0001→0000 0010以此类推
    duan_control;
    P0=duanma[display[discount]];	//段码
    if(++discount==8)discount=0;//计数值清零，以重新从第一位数码管开始
}

void delay(uint xms)//毫秒级延时，传入参数5则延时5ms，没有定时器准，一般用于数码管以及IIC连续调用之中。
{
    uint i,j;
    for(i=xms;i>0;i--)
        for(j=845;j>0;j--);
}

void init(void)
{
    control;
    P0=0x00;	//关闭蜂鸣器&继电器
    wei_control;
    P0=0xFF;	//选中所有数码管
    duan_control;
    P0=0xFF;	//关闭所有数码管
    led_control;
    P0=0xFF;	//关闭所有LED
}
```

## 14、矩阵按键-不干扰主循环<span name = "supplement14"></span>

```c
#include <STC15F2K60S2.h>
#include <intrins.h>

#define uchar unsigned char
#define uint unsigned int
	
#define control P2|=0XA0;P2&=0XBF;
#define wei_control P2|=0xC0;P2&=0xDF;
#define duan_control P2|=0xE0;P2&=0xFF;
#define led_control P2|=0x80;P2&=0x9F;

bit Line1_down=0;Line2_down=0;Line3_down=0;Line4_down=0;

uchar code duanma[]={0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90,0xBF,0xFF};

uchar display[8]={1,2,3,4,5,6,7,8};//此数组下标0~7分别对应第1~8位数码管。
uchar discount=0;					//用于计数点亮到第几个数码管

sbit DQ = P1^4;  //单总线接口

void Timer2Init(void);
void init(void);
uchar ds18b20_get(void);

uchar key_temp,key_down=0,key_up=0,key_property=0;
uchar check_time=0;
uchar number=20;
uchar wendu;
void main(void)
{
	init();
	Timer2Init();
	while(1)
	{
		wendu=ds18b20_get();
		display[0]=number/10;display[1]=number%10;
		display[2]=11;display[3]=11;display[4]=11;display[5]=11;
		display[6]=wendu/10;display[7]=wendu%10;
	}
}

void Timer2Init(void)		//1毫秒@12.000MHz
{
	AUXR |= 0x04;		//定时器时钟1T模式
	T2L = 0x20;		//设置定时初值
	T2H = 0xD1;		//设置定时初值
	AUXR |= 0x10;		//定时器2开始计时
    IE2 |= 0x04;	//开启定时器2中断
    EA = 1;			//打开总中断
}

void tim2_isr() interrupt 12 //定时器2的中断服务号为12
{
    wei_control;
    P0=(1<<discount);			//0000 0001→0000 0010以此类推
    duan_control;
    P0=duanma[display[discount]];	//段码
    if(++discount==8)discount=0;//计数值清零，以重新从第一位数码管开始
	
		//以下为矩阵按键部分
		check_time++;						//扫描计时
		if(check_time==5)				//5ms扫描一次
		{
			check_time=0;					//扫描计时标志位清零
			P3=0xFF;P4=0XEF;
			key_temp=P3;
			key_temp=key_temp&0x0F;
			if(key_temp!=0x0F)
			{
					key_down++;				
					if(key_down==2)		//消抖
					{
						Line1_down=1;		//第一列按键按下
						key_down=0;
						key_temp=P3;
						switch(key_temp)
						{
							 case 0xFE:key_property=7;break;		//具体到S?被按下，下同
							 case 0xFD:key_property=6;break;
							 case 0xFB:key_property=5;break;
							 case 0xF7:key_property=4;break;
						}
					}
			}
			else if((key_temp==0x0F)&&(Line1_down==1))	//松手检测
			{
				key_up++;
			}
			
			P3=0xFF;P4=0XFB;
			key_temp=P3;
			key_temp=key_temp&0x0F;
			if(key_temp!=0x0F)
			{
					key_down++;
					if(key_down==2)		//消抖
					{
						Line2_down=1;		//第二列按键按下
						key_down=0;
						key_temp=P3;
						switch(key_temp)
						{
							 case 0xFE:key_property=11;break;
							 case 0xFD:key_property=10;break;
							 case 0xFB:key_property=9;break;
							 case 0xF7:key_property=8;break;
						}
					}
			}
			else if((key_temp==0x0F)&&(Line2_down==1))	//松手检测
			{
				key_up++;
			}
			
			P3=0xDF;P4=0XFF;
			key_temp=P3;
			key_temp=key_temp&0x0F;
			if(key_temp!=0x0F)
			{
					key_down++;
					if(key_down==2)		//消抖
					{
						Line3_down=1;		//第三列按键按下
						key_down=0;
						key_temp=P3;
						switch(key_temp)
						{
							 case 0xDE:key_property=15;break;
               				 case 0xDD:key_property=14;break;
               				 case 0xDB:key_property=13;break;
              				 case 0xD7:key_property=12;break;
						}
					}
			}
			else if((key_temp==0x0F)&&(Line3_down==1))	//松手检测
			{
				key_up++;
			}
			
			P3=0xEF;P4=0XFF;
			key_temp=P3;
			key_temp=key_temp&0x0F;
			if(key_temp!=0x0F)
			{
					key_down++;
					if(key_down==2)		//消抖
					{
						Line4_down=1;		//第四列按键按下
						key_down=0;
						key_temp=P3;
						switch(key_temp)
						{
							 case 0xEE:key_property=19;break;
          				     case 0xED:key_property=18;break;
          				     case 0xEB:key_property=17;break;
           				     case 0xE7:key_property=16;break;
						}
					}
			}
			else if((key_temp==0x0F)&&(Line4_down==1))	//松手检测
			{
				key_up++;
			}
			
			if((key_up==2)&&(key_property!=0))				//判断是否已经有按键按下并松开手
			{
					key_up=0;									
					Line1_down=0;Line2_down=0;Line3_down=0;Line4_down=0; //标志位清零
					switch(key_property)
					{
						case 7:number=7;key_property=0;/*S7-function*/break;
						case 6:number=6;key_property=0;/*S6-function*/break;
						case 5:number=5;key_property=0;/*S5-function*/break;
						case 4:number=4;key_property=0;/*S4-function*/break;
						
						case 11:number=11;key_property=0;/*S11-function*/break;
						case 10:number=10;key_property=0;/*S10-function*/break;
						case 9:number=9;key_property=0;/*S9-function*/break;
						case 8:number=8;key_property=0;/*S8-function*/break;
						
						case 15:number=15;key_property=0;/*S15-function*/break;
						case 14:number=14;key_property=0;/*S14-function*/break;
						case 13:number=13;key_property=0;/*S13-function*/break;
						case 12:number=12;key_property=0;/*S12-function*/break;
						
						case 19:number=19;key_property=0;/*S19-function*/break;
						case 18:number=18;key_property=0;/*S18-function*/break;
						case 17:number=17;key_property=0;/*S17-function*/break;
						case 16:number=16;key_property=0;/*S16-function*/break;
						default:key_property=0;break;
					}
			}
		}
}

//单总线延时函数
void Delay_OneWire(unsigned int t)  //STC89C52RC
{
	while(t--);
}

//通过单总线向DS18B20写一个字节
void Write_DS18B20(unsigned char dat)
{
	unsigned char i;
	for(i=0;i<8;i++)
	{
		DQ = 0;
		DQ = dat&0x01;
		Delay_OneWire(40);
		DQ = 1;
		dat >>= 1;
	}
	Delay_OneWire(40);
}

//从DS18B20读取一个字节
unsigned char Read_DS18B20(void)
{
	unsigned char i;
	unsigned char dat;
  
	for(i=0;i<8;i++)
	{
		DQ = 0;
		dat >>= 1;
		DQ = 1;
		if(DQ)
		{
			dat |= 0x80;
		}	    
		Delay_OneWire(40);
	}
	return dat;
}

//DS18B20设备初始化
bit init_ds18b20(void)
{
  	bit initflag = 0;
  	
  	DQ = 1;
  	Delay_OneWire(96);
  	DQ = 0;
  	Delay_OneWire(640);
  	DQ = 1;
  	Delay_OneWire(80); 
    initflag = DQ;     
  	Delay_OneWire(40);
  
  	return initflag;
}

uchar ds18b20_get(void)
{
    uchar temp;
    uchar low,high;
    init_ds18b20();
	Write_DS18B20(0xCC);	//无视64位ID序列码
	Write_DS18B20(0x44);	//温度转换指令
	Delay_OneWire(200);		//等待温度转换完成
	init_ds18b20();
	Write_DS18B20(0xCC);
	Write_DS18B20(0xBE);	//读取温度数值
	low=Read_DS18B20();
	high=Read_DS18B20();
	temp=high<<4;			//舍弃高四位（正负值）
	temp|=(low>>4);			//舍弃第四位（小数部分）
	return temp;
}

void init(void)
{
    control;
    P0=0x00;	//关闭蜂鸣器&继电器
    wei_control;
    P0=0xFF;	//选中所有数码管
    duan_control;
    P0=0xFF;	//关闭所有数码管
    led_control;
    P0=0xFF;	//关闭所有LED
}
```

## 15、NE555-脉冲捕获<span name = "supplement15"></span>

```c
#include <STC15F2K60S2.h>
#include <intrins.h>

#define uchar unsigned char
#define uint unsigned int
	
#define control P2|=0XA0;P2&=0XBF;
#define wei_control P2|=0xC0;P2&=0xDF;
#define duan_control P2|=0xE0;P2&=0xFF;
#define led_control P2|=0x80;P2&=0x9F;


uchar code duanma[]={0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90,0xBF,0xFF};

uchar display[8]={1,2,3,4,5,6,7,8};//此数组下标0~7分别对应第1~8位数码管。
uchar discount=0;					//用于计数点亮到第几个数码管


void Timer0Init(void);
void Timer2Init(void);
void init(void);

uint check_time=0;
uint freq=0;

void main(void)
{
	init();
	Timer0Init();
	Timer2Init();
	while(1)
	{
		display[0]=22;display[1]=21;display[2]=21;
		if(freq>=10000){display[3]=freq/10000;display[4]=freq%10000/1000;display[5]=freq%1000/100;display[6]=freq%100/10;display[7]=freq%10;}
		else if(freq>=1000){display[3]=21;display[4]=freq%10000/1000;display[5]=freq%1000/100;display[6]=freq%100/10;display[7]=freq%10;}
		else if(freq>=100){display[3]=21;display[4]=21;display[5]=freq%1000/100;display[6]=freq%100/10;display[7]=freq%10;}
		else if(freq>=10){display[3]=21;display[4]=21;display[5]=21;display[6]=freq%100/10;display[7]=freq%10;}
	}
}

void Timer0Init(void) //计数模式
{
	AUXR |= 0x80;
	TMOD |= 0x05; //  C/~T置1 令定时器0作计数器使用  工作模式为16位不可重装载
	TL0=0;
	TH0=0;
	TR0=1;
}

void Timer2Init(void)		//1毫秒@12.000MHz
{
	AUXR |= 0x04;		//定时器时钟1T模式
	T2L = 0x20;		//设置定时初值
	T2H = 0xD1;		//设置定时初值
	AUXR |= 0x10;		//定时器2开始计时
    IE2 |= 0x04;	//开启定时器2中断
    EA = 1;			//打开总中断
}

void tim2_isr() interrupt 12 //定时器2的中断服务号为12
{
    wei_control;
    P0=(1<<discount);			//0000 0001→0000 0010以此类推
    duan_control;
    P0=duanma[display[discount]];	//段码
    if(++discount==8)discount=0;//计数值清零，以重新从第一位数码管开始
	
		//以下为NE555频率测量部分
		check_time++;						//扫描计时
		if(check_time==999)				//以1S为周期计算脉冲计数
		{
			check_time=0;
			freq=(TH0<<8)|TL0; //取出脉冲计数值
			TL0=0;TH0=0;				//清零 重新计数
		}
}

void init(void)
{
    control;
    P0=0x00;	//关闭蜂鸣器&继电器
    wei_control;
    P0=0xFF;	//选中所有数码管
    duan_control;
    P0=0xFF;	//关闭所有数码管
    led_control;
    P0=0xFF;	//关闭所有LED
}
```

## 16、NE555-定时器测量<span name = "supplement16"></span>

```c
#include <STC15F2K60S2.h>
#include <intrins.h>

#define uchar unsigned char
#define uint unsigned int
	
#define control P2|=0XA0;P2&=0XBF;
#define wei_control P2|=0xC0;P2&=0xDF;
#define duan_control P2|=0xE0;P2&=0xFF;
#define led_control P2|=0x80;P2&=0x9F;


uchar code duanma[]={0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90,0xBF,0xFF};

uchar display[8]={1,2,3,4,5,6,7,8};//此数组下标0~7分别对应第1~8位数码管。
uchar discount=0;					//用于计数点亮到第几个数码管


void Timer0Init(void);
void Timer2Init(void);
void init(void);

uint fan=0,zheng=0,zheng_now=0,fan_now=0;
uchar t_flag=0;
uint Time=0;
uint check_time=0;
uint freq=0;

void main(void)
{
	init();
	Timer0Init();
	Timer2Init();
	while(1)
	{
		display[0]=11;display[1]=11;display[2]=11;
		if(freq>=10000){display[3]=freq/10000;display[4]=freq%10000/1000;display[5]=freq%1000/100;display[6]=freq%100/10;display[7]=freq%10;}
		else if(freq>=1000){display[3]=21;display[4]=freq%10000/1000;display[5]=freq%1000/100;display[6]=freq%100/10;display[7]=freq%10;}
		else if(freq>=100){display[3]=21;display[4]=21;display[5]=freq%1000/100;display[6]=freq%100/10;display[7]=freq%10;}
		else if(freq>=10){display[3]=21;display[4]=21;display[5]=21;display[6]=freq%100/10;display[7]=freq%10;}
	}
}

void Timer0Init(void)		//5微秒@12.000MHz
{
	AUXR |= 0x80;		//定时器时钟1T模式
	TMOD &= 0xF0;		//设置定时器模式
	TL0 = 0xC4;		//设置定时初值
	TH0 = 0xFF;		//设置定时初值
	TF0 = 0;		//清除TF0标志
}

void tm0_isr() interrupt 1
{
  if(P34==0)				//当前处于反周期？
	{
		fan++;					//反周期计数
		if(t_flag==0)		//正周期计数完毕
		{
			t_flag=1;
			zheng_now=zheng;		//提取正周期计数值，用于计算
			zheng=0;
		}
	}
	else if(P34==1)		//当前处于正周期？
	{
		zheng++;				//正周期计数
		if(t_flag==1)		//反周期计数完毕
		{
			t_flag=0;
			fan_now=fan;				//提取反周期计数值，用于计算
			fan=0;
		}
	}
}

void Timer2Init(void)		//1毫秒@12.000MHz
{
	AUXR |= 0x04;		//定时器时钟1T模式
	T2L = 0x20;		//设置定时初值
	T2H = 0xD1;		//设置定时初值
	AUXR |= 0x10;		//定时器2开始计时
    IE2 |= 0x04;	//开启定时器2中断
    EA = 1;			//打开总中断
}

void tim2_isr() interrupt 12 //定时器2的中断服务号为12
{
    wei_control;
    P0=(1<<discount);			//0000 0001→0000 0010以此类推
    duan_control;
    P0=duanma[display[discount]];	//段码
    if(++discount==8)discount=0;//计数值清零，以重新从第一位数码管开始
	
		//以下为NE555频率测量部分
		check_time++;						//扫描计时
		if(check_time==969)
		{
			TR0 = 1;ET0 = 1 ;					//开始频率采集
		}
		else if(check_time==999)
		{
			check_time=0;
			TR0 = 0;ET0 = 0 ;
			Time=(fan_now+zheng_now)*5; //计算一个周期的时间，因为5us一次中断，所以乘以5，此处得到的时间单位是us。
			freq=1000000/Time;         //因为时间单位是us，所以要乘以10^-6，这里直接移到分子上。此处得到的频率单位是Hz。
		}
}

void init(void)
{
    control;
    P0=0x00;	//关闭蜂鸣器&继电器
    wei_control;
    P0=0xFF;	//选中所有数码管
    duan_control;
    P0=0xFF;	//关闭所有数码管
    led_control;
    P0=0xFF;	//关闭所有LED
}
```

## 17、超声波测距<span name = "supplement17"></span>

```c
#include <STC15F2K60S2.h>
#include <intrins.h>

#define uchar unsigned char
#define uint unsigned int
	
#define control P2|=0XA0;P2&=0XBF;
#define wei_control P2|=0xC0;P2&=0xDF;
#define duan_control P2|=0xE0;P2&=0xFF;
#define led_control P2|=0x80;P2&=0x9F;

#define sound_somenop {_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();}


uchar code duanma[]={0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90,0xBF,0xFF};

uchar display[8]={1,2,3,4,5,6,7,8};//此数组下标0~7分别对应第1~8位数码管。
uchar discount=0;					//用于计数点亮到第几个数码管

sbit TX=P1^0;
sbit RX=P1^1;

void Timer0Init(void);
void Timer1Init(void);
void Timer2Init(void);
void init(void);

void distance_get(void);

bit sound_flag=0;
uint time0_flag=0,sound_time=0,distance=0;

void main(void)
{
	init();
	Timer0Init();
	Timer1Init();
	Timer2Init();
	while(1)
	{
		distance_get();
		display[0]=11;display[1]=11;display[2]=11;display[3]=11;
		display[4]=distance/1000;display[5]=distance%1000/100;display[6]=distance%100/10;display[7]=distance%10; 
	}
}

void Timer1Init(void)		
{
	AUXR |= 0x40;		//定时器时钟1T模式
	TMOD &= 0x0F;		//设置定时器模式
}

void send_wave(void)
{
	uchar i=8;
	do
	{
		TX=1;
		sound_somenop;sound_somenop;sound_somenop;sound_somenop;sound_somenop;
		sound_somenop;sound_somenop;sound_somenop;sound_somenop;sound_somenop;
		
		TX=0;
		sound_somenop;sound_somenop;sound_somenop;sound_somenop;sound_somenop;
		sound_somenop;sound_somenop;sound_somenop;sound_somenop;sound_somenop;
	}
	while(i--);
}

void distance_get(void)
{
	if(sound_flag==1)				//以一定时间间隔进行超声波距离检测，原因见下等待回波部分注释
	{
		sound_flag=0;					//标志位清零
		send_wave();					//发送波形函数
		TR1=1;								//启动定时器1，开始计时
		while((RX==1)&&(TF1==0))			//发送波形完成后使用一段死循环等待回波，收到回波后RX引脚会被拉低，从而跳出循环
		{															//如果定时器1计数值溢出，则也跳出循环，防止在检测超范围时程序跑飞。
																	//如果不限制更新数据的时间，程序运行的大部分时间会在跑这段循环。
				//下面这段代码是为了照顾使用软件延时进行数码管显示
				//程序在跑入死循环等待回波时，main函数while(1)中的显示函数将不会被运行
				//此时可以观察到的现象大概为数码管闪烁
				//解决方法如下，当定时器1计时到一定时间时，运行一次显示函数
//			if((TH1==0x40)|(TH1==0x80)|(TH1==0xA0)|(TH1==0xE0))
//			{
//				display1(one,two);display2(three,four);display3(five,six);display4(seven,eight);
//			}
		}
		TR1=0;							//收到回波或定时器1计数值溢出，令定时器1停止计时。
		if(TF1==1)					//对定时器1的溢出标志位进行判断
		{
			TF1=0;						//将定时器1的溢出标志位重新置0
			distance=9999;		//9999 代表无返回，溢出
		}
		else
		{
			sound_time=TH1;		
			sound_time<<=8;
			sound_time|=TL1;	//将定时器1中的计数值取出
			
			distance=(uint)(sound_time*0.017);
			//此处的公式为，d=t/1000000*340/2*100
			//定时器的计数值增加方式为，每经过一个机器周期，计数器中值加1，直到计数器中的值溢出。
			//以STC89C52单片机工作在12MHz下为例，52单片机中，一个机器周期=12个晶振周期，12M/12=1M，除以1M得到具体时间，单位为S。
			//声音的传播速度约为340m/s
			//因为测得的时间是超声波往返一起花费的时间，所以要除以2。
			//这样计算出来后单位为m，因为题目中一般要求为cm，所以乘以100。
			
			distance=distance/12;
			//上方注释的计算是以52单片机为例的，但是在IAP15F2K61S2单片机中，一个机器周期=一个晶振周期。
			//所以当两者都处于12MHz下时，15单片机比52单片机快12倍，这里将多的12倍除去。
		}
		TH1=0;	//将定时器1的计数值清零
		TL1=0;
	}
}

void Timer0Init(void)		//2毫秒@12.000MHz
{
	AUXR |= 0x80;		//定时器时钟1T模式
	TMOD &= 0xF0;		//设置定时器模式
	TL0 = 0x40;		//设置定时初值
	TH0 = 0xA2;		//设置定时初值
	TF0 = 0;		//清除TF0标志
	TR0 = 1;		//定时器0开始计时
	ET0 = 1;		//开启定时器0中断
}

void time0_isr() interrupt 1
{
	time0_flag++;
	if(time0_flag==100)		//每200ms启动一次超声波检测
	{
		time0_flag=0;
		sound_flag=1;
	}
}

void Timer2Init(void)		//1毫秒@12.000MHz
{
	AUXR |= 0x04;		//定时器时钟1T模式
	T2L = 0x20;		//设置定时初值
	T2H = 0xD1;		//设置定时初值
	AUXR |= 0x10;		//定时器2开始计时
    IE2 |= 0x04;	//开启定时器2中断
    EA = 1;			//打开总中断
}

void tim2_isr() interrupt 12 //定时器2的中断服务号为12
{
    wei_control;
    P0=(1<<discount);			//0000 0001→0000 0010以此类推
    duan_control;
    P0=duanma[display[discount]];	//段码
    if(++discount==8)discount=0;//计数值清零，以重新从第一位数码管开始
}

void init(void)
{
    control;
    P0=0x00;	//关闭蜂鸣器&继电器
    wei_control;
    P0=0xFF;	//选中所有数码管
    duan_control;
    P0=0xFF;	//关闭所有数码管
    led_control;
    P0=0xFF;	//关闭所有LED
}
```

## 18、温度的小数显示<span name = "supplement18"></span>

```c
#include <STC15F2K60S2.h>
#include <intrins.h>

#define uchar unsigned char
#define uint unsigned int
	
#define control P2|=0XA0;P2&=0XBF;
#define wei_control P2|=0xC0;P2&=0xDF;
#define duan_control P2|=0xE0;P2&=0xFF;
#define led_control P2|=0x80;P2&=0x9F;

#define sound_somenop {_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();}


uchar code duanma[]={0xC0,0xF9,0xA4,0xB0,0x99,0x92,0x82,0xF8,0x80,0x90,
									 0x40,0x79,0x24,0x30,0x19,0x12,0x02,0x78,0x00,0x10,
									 0xBF,0xFF};

uchar display[8]={1,2,3,4,5,6,7,8};//此数组下标0~7分别对应第1~8位数码管。
uchar discount=0;					//用于计数点亮到第几个数码管

sbit DQ = P1^4;  //单总线接口

void Timer0Init(void);
void Timer2Init(void);
void init(void);

long DS18B20_GET(void);

bit wendu_flag=0;
uint time0_flag=0;
long wendu=0;
void main(void)
{
	init();
	Timer0Init();
	Timer2Init();
	while(1)
	{
		if(wendu_flag==1)
		{
			wendu_flag=0;
			wendu=DS18B20_GET();
		}
		display[0]=21;display[1]=21;display[2]=21;display[3]=21;
		display[4]=wendu/100000;
		display[5]=wendu%100000/10000+10;
		display[6]=wendu%10000/1000;
		display[7]=wendu%1000/100;
	}
}
//单总线延时函数
void Delay_OneWire(unsigned int t)  //STC89C52RC
{
	while(t--);
}

//通过单总线向DS18B20写一个字节
void Write_DS18B20(unsigned char dat)
{
	unsigned char i;
	for(i=0;i<8;i++)
	{
		DQ = 0;
		DQ = dat&0x01;
		Delay_OneWire(50);
		DQ = 1;
		dat >>= 1;
	}
	Delay_OneWire(50);
}

//从DS18B20读取一个字节
unsigned char Read_DS18B20(void)
{
	unsigned char i;
	unsigned char dat;
  
	for(i=0;i<8;i++)
	{
		DQ = 0;
		dat >>= 1;
		DQ = 1;
		if(DQ)
		{
			dat |= 0x80;
		}	    
		Delay_OneWire(50);
	}
	return dat;
}

//DS18B20设备初始化
bit init_ds18b20(void)
{
  	bit initflag = 0;
  	
  	DQ = 1;
  	Delay_OneWire(120);
  	DQ = 0;
  	Delay_OneWire(800);
  	DQ = 1;
  	Delay_OneWire(100); 
    initflag = DQ;     
  	Delay_OneWire(50);
  
  	return initflag;
}

long DS18B20_GET(void)
{
	uchar low,high;
	long temp;
	init_ds18b20();
	Write_DS18B20(0xCC);		//忽略64位ID序列码
	Write_DS18B20(0x44);		//温度转换指令
	Delay_OneWire(200);			//等待温度转换完成
	init_ds18b20();
	Write_DS18B20(0xCC);
	Write_DS18B20(0xBE);		//读取温度数值
	low=Read_DS18B20();
	high=Read_DS18B20();
	temp=(high&0x0F);
	temp<<=8;
	temp|=low;
	temp=temp*625;
	return temp;
}

void Timer0Init(void)		//2毫秒@12.000MHz
{
	AUXR |= 0x80;		//定时器时钟1T模式
	TMOD &= 0xF0;		//设置定时器模式
	TL0 = 0x40;		//设置定时初值
	TH0 = 0xA2;		//设置定时初值
	TF0 = 0;		//清除TF0标志
	TR0 = 1;		//定时器0开始计时
	ET0 = 1;		//开启定时器0中断
}

void time0_isr() interrupt 1
{
	time0_flag++;
	if(time0_flag==100)		//每200ms启动一次温度检测
	{
		time0_flag=0;
		wendu_flag=1;
	}
}

void Timer2Init(void)		//1毫秒@12.000MHz
{
	AUXR |= 0x04;		//定时器时钟1T模式
	T2L = 0x20;		//设置定时初值
	T2H = 0xD1;		//设置定时初值
	AUXR |= 0x10;		//定时器2开始计时
    IE2 |= 0x04;	//开启定时器2中断
    EA = 1;			//打开总中断
}

void tim2_isr() interrupt 12 //定时器2的中断服务号为12
{
    wei_control;
    P0=(1<<discount);			//0000 0001→0000 0010以此类推
    duan_control;
    P0=duanma[display[discount]];	//段码
    if(++discount==8)discount=0;//计数值清零，以重新从第一位数码管开始
}

void init(void)
{
    control;
    P0=0x00;	//关闭蜂鸣器&继电器
    wei_control;
    P0=0xFF;	//选中所有数码管
    duan_control;
    P0=0xFF;	//关闭所有数码管
    led_control;
    P0=0xFF;	//关闭所有LED
}
```

# 八、致谢

​	在这里感谢赵中琦、陈永强、范海健、崔鸣、刘淑芬、陈杰、张旭各位老师（排名不分先后）在我大学三年中对我学业以及人生上的指导，感谢各位老师让我在大学三年之中学有所思、学有所悟、学有所得。

# 九、更新日志

|   内容   |     日期      |  作者  |    备注    |
| :------: | :-----------: | :----: | :--------: |
| 完成初版 | 2021年3月20日 | 李明睿 |  版本1.0   |
| 添加致谢 | 2021年3月21日 | 李明睿 | 一点小私心 |











